<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-tw"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://homuchen.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://homuchen.com/" rel="alternate" type="text/html" hreflang="zh-tw" /><updated>2021-06-29T23:05:59+08:00</updated><id>https://homuchen.com/feed.xml</id><title type="html">HoMuChen</title><subtitle>Hi! This is HoMuchen, 陳河穆. I am a software engineer working at Largitdata now. This is where I record whatever I learned.</subtitle><entry><title type="html">[Google sheet]如何建立下拉選單，以及從既有資料中自動建立選項</title><link href="https://homuchen.com/posts/google-sheet-create-a-drop-down-list-from-existed-data/" rel="alternate" type="text/html" title="[Google sheet]如何建立下拉選單，以及從既有資料中自動建立選項" /><published>2021-06-26T20:00:00+08:00</published><updated>2021-06-26T20:00:00+08:00</updated><id>https://homuchen.com/posts/google-sheet-create-a-drop-down-list-from-existed-data</id><content type="html" xml:base="https://homuchen.com/posts/google-sheet-create-a-drop-down-list-from-existed-data/">&lt;h1 id=&quot;為什麼要用下拉式選單&quot;&gt;為什麼要用下拉式選單&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;新增資料更為快速，無需重複填寫&lt;/li&gt;
  &lt;li&gt;避免誤植，或統一資料的格式及規則&lt;/li&gt;
  &lt;li&gt;對既有資料鐘進行選擇及後續操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;如何建立下拉式選單&quot;&gt;如何建立下拉式選單&lt;/h1&gt;

&lt;h2 id=&quot;自行輸入清單選項&quot;&gt;自行輸入清單選項&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;首先選擇一個或多個你想要建立選單的儲存格&lt;/li&gt;
  &lt;li&gt;點選 &lt;strong&gt;資料&lt;/strong&gt; -&amp;gt; &lt;strong&gt;資料驗證&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-1.jpg&quot; alt=&quot;data validation: tool bar&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;條件&lt;/strong&gt;選項中，選取&lt;strong&gt;項目清單&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-2.jpg&quot; alt=&quot;data validation: List of items&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;輸入你想要的選項，選項間以逗號隔開
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-3.jpg&quot; alt=&quot;data validation: List of items&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;就大功告成拉
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-4.jpg&quot; alt=&quot;drop down menu&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;從既有資料來建立選項&quot;&gt;從既有資料來建立選項&lt;/h2&gt;

&lt;p&gt;有時你想要建立一個選單，其中的選項是來自某一大筆資料中的某一個欄位，
你不想一筆一筆手動Key，而且你也不想每次資料有變動時，就要重新去更新一次資料驗證，
此時就可以這麼做，以以下的資料為例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-5.jpg&quot; alt=&quot;example data sheet&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;重複自行輸入清單選項中的第一及第二部&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;條件&lt;/strong&gt;選項中，選取&lt;strong&gt;範圍內的清單&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-6.jpg&quot; alt=&quot;data validation: List from a range&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;輸入或選取一個範圍，以這裡的例子為例，我們建立一個國家的下拉選項，填入&lt;strong&gt;F2:F&lt;/strong&gt;，代表country那一欄，不包含標頭country本身&lt;/li&gt;
  &lt;li&gt;大功告成~
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-7.jpg&quot; alt=&quot;drop down menu from a range&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;建立一個下拉選單，選項可以自行輸入，也可以從既有資料的範圍中建立，如此一來當資料有變動時，下拉選單的選項就可以自動更新，而不需要自己再重新輸入新的選項!&lt;/p&gt;</content><author><name>HoMuChen</name></author><category term="Google Sheet" /><category term="google sheet" /><category term="drop down list" /><summary type="html">為什麼要用下拉式選單</summary></entry><entry><title type="html">RESTful API Design — A practical guide</title><link href="https://homuchen.com/posts/http-restful-api-design-practical-guide/" rel="alternate" type="text/html" title="RESTful API Design — A practical guide" /><published>2021-04-13T20:00:00+08:00</published><updated>2021-04-13T20:00:00+08:00</updated><id>https://homuchen.com/posts/http-restful-api-design-practical-guide</id><content type="html" xml:base="https://homuchen.com/posts/http-restful-api-design-practical-guide/">&lt;p&gt;此篇文章將作為接下來一系列關於Restful API design的目錄．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 1:&lt;/strong&gt; 將介紹什麼是API，何時需要他，以及怎樣才會是一個好的API．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 2:&lt;/strong&gt; 在許多種API中，此系列只專注於HTTP RESTful API，為了更好地學習他，必須先了解HTTP Protocol，知道其中各個組成HTTP Message的每一個部分．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 3:&lt;/strong&gt; 介紹何為RESTful API，為什麼他會長這樣，以及其他許多當你在設計API時會遇到情況，例如: Documentation、Pagination、Rate Limiting、Monitoring．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 4:&lt;/strong&gt; 陸續想到一些相關的議題，再放上來！&lt;/p&gt;

&lt;h1 id=&quot;outline&quot;&gt;Outline&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Introduction
    &lt;ul&gt;
      &lt;li&gt;1.1 What is an API?&lt;/li&gt;
      &lt;li&gt;1.2 What is a good API?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP Basics
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/posts/http-introduction-telnet-nc-curl&quot;&gt;2.1 A HTTP Overview&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/posts/http-methods-which-to-use-and-how-to-use-them-correctly&quot;&gt;2.2 HTTP Methods&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;2.3 HTTP Response codes&lt;/li&gt;
      &lt;li&gt;2.4 HTTP URI&lt;/li&gt;
      &lt;li&gt;2.5 HTTP Headers&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/posts/linux-http-client-tool-curl-usage/&quot;&gt;2.6 [Practices] A HTTP client — curl&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RESTful API and some Practical Guidelines
    &lt;ul&gt;
      &lt;li&gt;3.1 What is a RESTful API?&lt;/li&gt;
      &lt;li&gt;3.2 Identifying Resources&lt;/li&gt;
      &lt;li&gt;3.2 API first&lt;/li&gt;
      &lt;li&gt;3.3 An Introduction to OpenAPI&lt;/li&gt;
      &lt;li&gt;3.4 [Practices] How do I manage a large OpenAPI spec file?&lt;/li&gt;
      &lt;li&gt;3.5 Pagination&lt;/li&gt;
      &lt;li&gt;3.6 Rate Limiting&lt;/li&gt;
      &lt;li&gt;3.7 Monitoring&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Advanced Topics
    &lt;ul&gt;
      &lt;li&gt;4.1 Connection management&lt;/li&gt;
      &lt;li&gt;4.2 Resource Modeling: Fine-grained or Coarse-grained?&lt;/li&gt;
      &lt;li&gt;4.3 Versioning and Compatibility&lt;/li&gt;
      &lt;li&gt;4.4 How to Response to a Health Check?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>HoMuChen</name></author><category term="API Design" /><category term="api" /><category term="http" /><category term="restful api" /><summary type="html">此篇文章將作為接下來一系列關於Restful API design的目錄．</summary></entry><entry><title type="html">What are HTTP Methods？Which to use and How to use them correctly?</title><link href="https://homuchen.com/posts/http-methods-which-to-use-and-how-to-use-them-correctly/" rel="alternate" type="text/html" title="What are HTTP Methods？Which to use and How to use them correctly?" /><published>2021-04-04T20:00:00+08:00</published><updated>2021-04-04T20:00:00+08:00</updated><id>https://homuchen.com/posts/http-methods-which-to-use-and-how-to-use-them-correctly</id><content type="html" xml:base="https://homuchen.com/posts/http-methods-which-to-use-and-how-to-use-them-correctly/">&lt;p&gt;這篇文章主要討論幾個常見的HTTP methods，說明他們分別是否具有哪些特性(Safe、Idempotent)，以及他們應該要怎麼使用，比較會是符合大家的期待．&lt;/p&gt;

&lt;p&gt;當然寫server的人可以不照著慣例走，不過如此一來，使用這個API的user可能會很不高興，而這個user可以是公司的客戶，可能是公司內部的其他團隊，也可能是未來的自己！&lt;/p&gt;

&lt;h1 id=&quot;outline&quot;&gt;Outline&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP Request message格式&lt;/li&gt;
  &lt;li&gt;常見的methods，以及其特性&lt;/li&gt;
  &lt;li&gt;分別介紹各個method的用法&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;http-request-message&quot;&gt;HTTP Request message&lt;/h1&gt;
&lt;p&gt;一個general的HTTP request message如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;method&amp;gt; &amp;lt;URL&amp;gt; &amp;lt;version&amp;gt;
&amp;lt;header&amp;gt;
...
...
&amp;lt;header&amp;gt;
&amp;lt;body&amp;gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一個字就是method，接著為URL跟version，換行後為許多個header，每個header以換行隔開，最後再隔一行之後是body．&lt;/p&gt;

&lt;p&gt;對於HTTP message還不熟的，可以看我之前寫的文章：&lt;a href=&quot;/posts/http-introduction-telnet-nc-curl&quot;&gt;[Networking] HTTP 簡介，以及使用telnet、nc、curl等指令來探索&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;URL代表著資源，而method是你想要對資源進行的操作，常見的method如下表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/header-1.jpg&quot; alt=&quot;http headers&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;dont-surprise-your-user&quot;&gt;Don’t surprise your user&lt;/h1&gt;
&lt;p&gt;並不是所有的server都會實作所有的method，而且每個method要做什麼事，也都是由server所決定的，但是一個好的API通常不會做怪怪的事，而是要符合使用者的期待，使其體驗良好，這裡先來解釋一下safe及Idempotent這兩個特性是什麼吧．&lt;/p&gt;
&lt;h2 id=&quot;safe&quot;&gt;Safe&lt;/h2&gt;
&lt;p&gt;如果一個request是safe的，指的是他不會導致server去做一些額外的動作，沒有side effect，例如說改變state、刷你信用卡，這樣的request基本上就是read-only的．
這樣的特性，使得API的user可以大膽放心地去呼叫，實驗你的API，而不必擔心會引發什麼無法挽回的後果，GET、HEAD、OPTIONS都是具有safe特性的method．&lt;/p&gt;
&lt;h2 id=&quot;idempotent&quot;&gt;Idempotent&lt;/h2&gt;
&lt;p&gt;一個Idempotent的操作，指的是這樣的操作執行一次跟執行很多次的結果是一樣的．例如數學上的乘以1，乘以0，一個是數字乘以1或乘以0不管多少次，結果都是原本的數字或者是0．&lt;/p&gt;

&lt;p&gt;那有Idempotent的特性，可以帶來什麼好處呢？就是user可以放心的retry，當user不確定剛剛的operation、request有沒有成功時(可能送出後網路突然斷掉、server做完之後再回應之前掛掉、等等…)，就再做一次！&lt;/p&gt;

&lt;p&gt;而HTTP method中，除了POST，其他method都預期應該是Idempotent的，Update好幾次，Delete好幾次，應該都跟只做一次的結果一致．&lt;/p&gt;

&lt;h1 id=&quot;http-methods&quot;&gt;HTTP Methods&lt;/h1&gt;
&lt;p&gt;看完了共同的特性之後，接著來看看給個method預期是怎麼使用，以及server如何回應各種情況．&lt;/p&gt;

&lt;h2 id=&quot;get&quot;&gt;GET&lt;/h2&gt;
&lt;p&gt;最常見的method之一，顧名思義就是用來向server索取一些資源．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;有資源，server就回應200以及資源&lt;/li&gt;
  &lt;li&gt;沒有資源，404&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;head&quot;&gt;HEAD&lt;/h2&gt;
&lt;p&gt;跟GET都一樣，但server並不回傳資源本身，而是只回應headers．&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Response&amp;gt;
HTTP/1.1 200 OK
Content-Type: plain/html
Content-Length: 614
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;options&quot;&gt;OPTIONS&lt;/h2&gt;
&lt;p&gt;用來詢問server對特定的資源，有支援哪些操作．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;將結果置於header Allow裡，如下：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Response&amp;gt;
HTTP/1.1 200 OK
Allow: GET, POST, PUT, OPTIONS
Content-Length: 0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;put&quot;&gt;PUT&lt;/h2&gt;
&lt;p&gt;Replace the entire resource，對應到CRUD裡的update，就是叫server將我request body裡的資料存起來，如果資源本來不存在就create，在的話就replace．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200 OK，成功&lt;/li&gt;
  &lt;li&gt;204 No Content，成功但畫面不需要更新，也就是沒有新的資料產生，client不必取的新的資料，例如說client在更新表單按下save時．&lt;/li&gt;
  &lt;li&gt;201 Created，如果是create的話，並且在header Location放上資源的URI
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Response&amp;gt;
HTTP/1.1 201 Created
Location: https://api.example.com/users/123 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;patch&quot;&gt;PATCH&lt;/h2&gt;
&lt;p&gt;Update parts of the resource，跟PUT一樣是update，不過是partial update或者說是merge．
比如說原本有個homuchen的user是長這樣：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
    &quot;name&quot;: &quot;HoMuChen&quot;,
    &quot;age&quot;: 30
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;當你PATCH時，想要將age更新為31&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Request&amp;gt;
PATCH /users/homuchen HTTP/1.1
Content-Type: application/json
Content-Length: 11
{&quot;age&quot;: 31}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;結果為&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
    &quot;name&quot;: &quot;HoMuChen&quot;,
    &quot;age&quot;: 31
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果是用PUT，則會整個replace掉，name就不見了&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
    &quot;age&quot;: 31
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;post&quot;&gt;POST&lt;/h2&gt;
&lt;p&gt;一般來說是指把資料傳給server去做處理，當使用其他的method，語意無法符合時，就會使用POST，常見的有用於Create resources、Search query、Asynchronous tasks．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200 OK&lt;/li&gt;
  &lt;li&gt;201 Created&lt;/li&gt;
  &lt;li&gt;202 Accepted，server已接受請求，但還需要時間去完成任務．&lt;/li&gt;
  &lt;li&gt;Search Query: Ex. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&quot;&gt;Elasticsearch Query DSL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;delete&quot;&gt;DELETE&lt;/h2&gt;
&lt;p&gt;顧名思義，用來刪除資源．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200 OK．&lt;/li&gt;
  &lt;li&gt;207，bulk delete．&lt;/li&gt;
  &lt;li&gt;404 Not Found，要刪除的資源不存在．&lt;/li&gt;
  &lt;li&gt;410 Gone，資源已被刪除．&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;HTTP做為網路世界中眾多通訊協定中的一個，只有當我們更加了解他，service provider才能提供更好用、另client user的學習曲線低，用起來很開心的服務．&lt;/p&gt;

&lt;p&gt;今天簡單地討論了各個HTTP Method的用法，每個method有他的語意，只有當server照著大家的預期去做時，才不會造成大家的困擾．&lt;/p&gt;

&lt;p&gt;除了Method之外，還有Response code、Header等其他HTTP的組成需要去了解，最後整個API符合RESTful的style是這一系列文章的目標．&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;感謝大家的閱讀，如有錯誤歡迎指正，我是河穆，我們下次見！&lt;/p&gt;</content><author><name></name></author><category term="API Design" /><category term="restful api" /><category term="api" /><category term="http" /><summary type="html">這篇文章主要討論幾個常見的HTTP methods，說明他們分別是否具有哪些特性(Safe、Idempotent)，以及他們應該要怎麼使用，比較會是符合大家的期待．</summary></entry><entry><title type="html">A Linux HTTP client tool — curl的介紹及用法</title><link href="https://homuchen.com/posts/linux-http-client-tool-curl-usage/" rel="alternate" type="text/html" title="A Linux HTTP client tool — curl的介紹及用法" /><published>2021-03-24T20:00:00+08:00</published><updated>2021-03-24T20:00:00+08:00</updated><id>https://homuchen.com/posts/linux-http-client-tool-curl-usage</id><content type="html" xml:base="https://homuchen.com/posts/linux-http-client-tool-curl-usage/">&lt;p&gt;做為一個HTTP client，想要對server發出請求，有許多做法，可能是寫一個python script 或使用其他任何語言，也可以是使用&lt;a href=&quot;https://www.postman.com/&quot;&gt;postman&lt;/a&gt;這樣的工具，或者是直接在command line上或shell script中使用curl指令．當你想要快速地測試一下某個API，或是explore別人的HTTP service時，直接使用curl是還蠻方便的！甚至直接用shell script來寫爬蟲了！&lt;/p&gt;

&lt;h1 id=&quot;outline&quot;&gt;Outline&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP Request message&lt;/li&gt;
  &lt;li&gt;Curl 的許多參數及用法&lt;/li&gt;
  &lt;li&gt;如何知道自己curl有沒有寫對&lt;/li&gt;
  &lt;li&gt;其他常見搭配的用法及使用情境&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/curl-1.jpg&quot; alt=&quot;curl&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;http-request-message&quot;&gt;HTTP Request message&lt;/h1&gt;

&lt;p&gt;作為一個HTTP client，要送出一個request，我們先必須知道送出去的message到底會有哪些東西組成．&lt;/p&gt;

&lt;h2 id=&quot;request-line&quot;&gt;Request line&lt;/h2&gt;
&lt;p&gt;HTTP message的第一行，由method、URL、version所組成，例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET /index.html HTTP/1.1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;header-lines&quot;&gt;Header lines&lt;/h2&gt;
&lt;p&gt;第二行開始，每一行是為一個header，field及value由冒號隔開，例如&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Host: www.google.com
Connection: Close
Accept-Language: en
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;body&quot;&gt;body&lt;/h2&gt;
&lt;p&gt;Header結束空一行之後是為body，method是GET的就沒有body，例如你的表單POST的一些資料就會放在body，可能長這樣：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;name=HoMu&amp;amp;phone=0912345678&amp;amp;email=homu@email.com
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;更多關於HTTP message的說明，可以看我之前寫過的文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/http-introduction-telnet-nc-curl&quot;&gt;[Networking] HTTP 簡介，以及使用telnet、nc、curl等指令來探索&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;curl&quot;&gt;Curl&lt;/h1&gt;
&lt;p&gt;所以我們要如何使用curl指令來產生HTTP message呢？！&lt;/p&gt;

&lt;h2 id=&quot;基本&quot;&gt;基本&lt;/h2&gt;
&lt;p&gt;URL是必須的，什麼參數都沒有，就產生一個GET message&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl www.google.com
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-x&quot;&gt;-X&lt;/h2&gt;
&lt;p&gt;設定你想要的method，例如你想要POST，如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -X POST api.host.com/v1/users
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-h&quot;&gt;-H&lt;/h2&gt;
&lt;p&gt;加上headers，用冒號隔開field及value，如果想要多個header就多打幾次-H，如：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -X POST \
     -H 'Content-Type: application/json' \
     -H 'X-Whatever-Field: value' \
     api.host.com/v1/users
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-d&quot;&gt;-d&lt;/h2&gt;
&lt;p&gt;加上body，比如你想POST JSON string的data給你的API：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -X POST -H 'Content-Type: application/json' localhost:3000/api -d '{&quot;name&quot;: &quot;HoMu&quot;, &quot;age&quot;: 30}'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你data很多，想在一個檔案裡頭，也可以使用指定檔案路徑的方式，可以為絕對路徑，也可以是相對的，路徑前必須加上@，例如：-d @./data.json&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -X POST -H 'Content-Type: application/json' localhost:3000/api -d @FILEPATH
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-i&quot;&gt;-i&lt;/h2&gt;
&lt;p&gt;按下Enter後，你得到會是server傳回來的body，如果你想要看response的header的話，要加上-i&lt;/p&gt;

&lt;h2 id=&quot;-f&quot;&gt;-F&lt;/h2&gt;
&lt;p&gt;上傳檔案&lt;/p&gt;

&lt;h1 id=&quot;利用nc指令看看自己到了傳了什麼&quot;&gt;利用nc指令看看自己到了傳了什麼&lt;/h1&gt;
&lt;p&gt;你可能寫了curl指令，不太確定用法，想知道到底curl形成出來的message是不是自己想要的格式，這時可以使用nc指令，在本機端起一個tcp server，在curl這個server，就可以看到HTTP的message囉．&lt;/p&gt;

&lt;h2 id=&quot;nc監聽在port-3000&quot;&gt;nc監聽在port 3000&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;nc -l 3000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;curl-port-3000&quot;&gt;curl port 3000&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl localhost:3000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;其他常見使用情況&quot;&gt;其他常見使用情況&lt;/h1&gt;
&lt;h2 id=&quot;redirect&quot;&gt;redirect&lt;/h2&gt;
&lt;p&gt;當curl回來的資料是html時，直接在terminal上噴出一堆字也是很難看，這時長搭配redirect io，把回傳回來的html string寫到檔案裡，就可以用瀏覽器打開來了．&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl www.google.com &amp;gt; gg.html
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;jq&quot;&gt;jq&lt;/h2&gt;
&lt;p&gt;如果content-type是json的話，可以使用jq command幫你parse，不然一堆json string噴在螢幕上，也是眼花．&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl api.host.com/users | jq
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;今天簡單看了一下HTTP message的格式，以及如何用curl來做出自己想要的HTTP Request，並且知道自己到底有沒有寫對．&lt;/p&gt;

&lt;p&gt;感謝大家的收看，如有錯誤歡迎指正，下次見！&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;參考資料&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jq - &lt;a href=&quot;https://stedolan.github.io/jq/&quot;&gt;https://stedolan.github.io/jq/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Networking" /><category term="http" /><category term="linux" /><category term="curl" /><summary type="html">做為一個HTTP client，想要對server發出請求，有許多做法，可能是寫一個python script 或使用其他任何語言，也可以是使用postman這樣的工具，或者是直接在command line上或shell script中使用curl指令．當你想要快速地測試一下某個API，或是explore別人的HTTP service時，直接使用curl是還蠻方便的！甚至直接用shell script來寫爬蟲了！</summary></entry><entry><title type="html">HTTP 簡介，以及使用telnet、nc、curl等指令來探索</title><link href="https://homuchen.com/posts/http-introduction-telnet-nc-curl/" rel="alternate" type="text/html" title="HTTP 簡介，以及使用telnet、nc、curl等指令來探索" /><published>2021-03-24T20:00:00+08:00</published><updated>2021-03-24T20:00:00+08:00</updated><id>https://homuchen.com/posts/http-introduction-telnet-nc-curl</id><content type="html" xml:base="https://homuchen.com/posts/http-introduction-telnet-nc-curl/">&lt;p&gt;在網路的世界裡，HTTP扮演著一個重要角色，當你打開Instagram看著無以計數的照片、打開Youtube看看影片、在google上搜尋著你想要知道的答案、瀏覽著別人的網站文章，這些都是HTTP負責把上述的這些照片、影片、文字、等檔案資源從別處的伺服器搬到你的裝置裡，可能是你的手機、平板或是電腦．&lt;/p&gt;

&lt;p&gt;HTTP在OSI模型中，是屬於應用層(Application layer)裡的一個通訊協定，透過傳輸層(Transport layer)的TCP來傳輸資料．&lt;/p&gt;

&lt;p&gt;關於application layer在整個分層架構中扮演什麼樣的角色，可以參考我之前寫的文章: &lt;a href=&quot;/posts/networking-application-layer-overview-what-is-socket&quot;&gt;[Networking]Application Layer Overview，什麼是Socket?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;client-server-protocol&quot;&gt;Client server protocol&lt;/h1&gt;
&lt;p&gt;HTTP是這樣的，想要發起通訊請求的一方作為client(例如你的瀏覽器)，而server則隨時等候，回應client的請求，client首先會建立一個TCP socket，至於TCP連線是怎麼建立，以及資料如何透過TCP connection在client及server之間傳送，則是另外一回事，並不是HTTP需要考慮的事．&lt;/p&gt;

&lt;p&gt;Client送出一個請求，例如我要看youtube! 而youtube的server收到這個請求，則回應給他youtube的介面，以及一些影片的清單．&lt;/p&gt;

&lt;p&gt;HTTP既然作為client及server之間的語言，他必須有個規範大家才聽得懂，不然有人講中文，有人說英文這樣是無法溝通的．以下就來看看HTTP所傳送的資料到底是長怎樣．&lt;/p&gt;

&lt;h1 id=&quot;http-message&quot;&gt;HTTP message&lt;/h1&gt;
&lt;p&gt;HTTP message分成兩種，請求(request)及回應(response)，他基本上就是人類可以讀懂的文字．&lt;/p&gt;

&lt;h2 id=&quot;request-message&quot;&gt;Request message&lt;/h2&gt;
&lt;p&gt;以下一個範例，當你在網址上輸入www.google.com時，你的瀏覽送出去的HTTP message可能會是這樣:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET / HTTP/1.1
Host: www.google.com
Connection: Close
User-agent: Mozilla/5.0
Accept-language: en
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一行為request line，由三個部分組成，method、URL、version，分別以空格隔開．&lt;/p&gt;

&lt;p&gt;常見的method有GET 、POST 、PUT 、DELETE 、HEAD等等，GET非常地常見，通常代表著你想要取得的某些資源，而你想取的資源則用URL表示，最後HTTP/1.1就是版本．&lt;a href=&quot;/posts/&quot;&gt;點我看更多關於method的介紹．&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第二行開始為header lines，field跟value以冒號(:)隔開，上面例子中有Host、Connection、User-agent、Accept-language四個header，還有許許多多的header各自有各自的意義，Host代表server，Connection: Close是叫server回傳完資料後就把TCP connection close掉，關於persistent connections的部分，之後會再寫一篇文章來詳細探討．&lt;/p&gt;

&lt;h2 id=&quot;request-body&quot;&gt;Request body&lt;/h2&gt;
&lt;p&gt;如果client需要傳送額外的資料給server，就要把資料放在body的部分，是在header lines之後空一行，比如說我要通過一個API新增一個user&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;POST /users HTTP/1.1
HOST: api.domain.com
Content-Type: application/json
Connection: Keep-alive
{&quot;name&quot;: &quot;HoMuChen&quot;, &quot;age&quot;: 30, &quot;gender&quot;: &quot;male&quot;}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;response-message&quot;&gt;Response message&lt;/h2&gt;
&lt;p&gt;以下為一個範例:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;HTTP/1.1 200 OK
Server: nginx/1.14.0 (Ubuntu)
Date: Wed, 17 Mar 2021 14:34:29 GMT
Content-Type: text/html
Content-Length: 614
Last-Modified: Wed, 17 Mar 2021 10:27:32 GMT
&amp;lt;!doctype html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;........
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;status-line&quot;&gt;Status Line&lt;/h2&gt;
&lt;p&gt;第一行為status line，由三個部分組成，version、status code、phrase，分別以空格隔開．
Status code 跟 phrase拜表著回應的結果，常見的有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;200 OK：成功&lt;/li&gt;
  &lt;li&gt;301 Moved Permanently: 資源不在此URL，通常搭配著Location的response header，告訴我們要去哪裡取得資源．&lt;/li&gt;
  &lt;li&gt;400 Bad Request: Request有錯，我server看不懂拉．&lt;/li&gt;
  &lt;li&gt;404 Not Found: 資源不存在．&lt;/li&gt;
  &lt;li&gt;500 Internal Server Error: Server出事了…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;header-lines&quot;&gt;Header Lines&lt;/h2&gt;
&lt;p&gt;第二行開始一樣是header lines，我覺得比較重要的是Content-Type，此header就是說明了放在最後body裡的資料是什麼格式，讓client可以去處理．常見的像是text/html、application/json、image/jpeg、application/pdf等等．&lt;/p&gt;

&lt;h2 id=&quot;body&quot;&gt;Body&lt;/h2&gt;
&lt;p&gt;結束header lines之後，空一行，後面就是response body的部分，放著的就是request想要的資料，上面例子中就是html document，也可能是一張圖片的binary data，或是一個Restful API的json資料．&lt;/p&gt;

&lt;h1 id=&quot;get-your-hands-dirty&quot;&gt;Get your hands dirty&lt;/h1&gt;
&lt;h2 id=&quot;telnet&quot;&gt;telnet&lt;/h2&gt;
&lt;p&gt;最後就來使用一些linux command line tool來驗證上面講的對不對吧！&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;telnet www.google.com 80
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用telnet指令，如此一來就跟google建立了一個TCP連線，接下來輸入並且按下Enter&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET / HTTP/1.1
Host: www.google.com
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/http-intro-1.jpg&quot; alt=&quot;telnet request response&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就可以看到google把網頁吐回來拉～～&lt;/p&gt;

&lt;h2 id=&quot;nccurl&quot;&gt;nc、curl&lt;/h2&gt;

&lt;p&gt;除了telnet之後，也可以用nc作為建立tcp連線的指令，這裡我們用nc來建立一個server，-l 監聽在本機的port 3000上&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;nc -l 3000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之後在另一個shell，利用curl作為HTTP client，發送HTTP到port 3000&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl localhost:3000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/http-intro-2.jpg&quot; alt=&quot;curl response&quot; /&gt;&lt;/p&gt;

&lt;p&gt;nc的terminal上就會出現這些資訊拉～～也就是curl傳送過來的資料，再來試試看上面開創一個新的user的API call吧&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -XPOST \
     -H 'Content-Type: application' \
     -H 'Connection: Keep-alive' \
     api.domain.com/users \
     -d '{&quot;name&quot;: &quot;HoMuChen&quot;, &quot;age&quot;: 30, &quot;gender&quot;: &quot;male&quot;}'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nc server就會收到下面的資料拉！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/http-intro-3.jpg&quot; alt=&quot;curl request&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;HTTP作為網路中最常用的client server 通訊協定，簡單地介紹了HTTP message的格式，他是human readable的text format，熟悉他到底傳來傳去到底在傳什麼，可以幫助我們開發網頁應用時更有底氣．&lt;/p&gt;

&lt;p&gt;也可以學習使用一些linux指令，快速的explore別人的API，或是看看自己送出去的request到底有沒有對．&lt;/p&gt;

&lt;p&gt;感謝您的閱讀~期待下次見！&lt;/p&gt;</content><author><name></name></author><category term="Networking" /><category term="http" /><category term="linux" /><category term="curl" /><category term="nc" /><category term="telnet" /><summary type="html">在網路的世界裡，HTTP扮演著一個重要角色，當你打開Instagram看著無以計數的照片、打開Youtube看看影片、在google上搜尋著你想要知道的答案、瀏覽著別人的網站文章，這些都是HTTP負責把上述的這些照片、影片、文字、等檔案資源從別處的伺服器搬到你的裝置裡，可能是你的手機、平板或是電腦．</summary></entry><entry><title type="html">[System Design]Data model: Relational V.S. Document</title><link href="https://homuchen.com/posts/system-design-data-model-relational-vs-document/" rel="alternate" type="text/html" title="[System Design]Data model: Relational V.S. Document" /><published>2020-12-28T20:00:00+08:00</published><updated>2020-12-28T20:00:00+08:00</updated><id>https://homuchen.com/posts/system-design-data-model-relational-vs-document</id><content type="html" xml:base="https://homuchen.com/posts/system-design-data-model-relational-vs-document/">&lt;p&gt;開發應用程式時，時常使用到資料庫，儲存資料並在之後需要時將其取出，如今有許多的資料庫產品可供選擇，提供各種不同的data model及function，在各種使用情境下有不同的表現，開發者根據你的應用程式的需求、資料之間的關係、access pattern、scalability、ACID transaction、fault-tolerance、會有各種不同的適合的選擇．&lt;/p&gt;

&lt;p&gt;接下來只單純討論資料庫提供給我們application programmer們的data model，看看是否在哪些情況比較適合用哪一種，主要是探討relational 及 document這兩種data model.&lt;/p&gt;

&lt;h1 id=&quot;one-to-many-relationship&quot;&gt;One-to-many relationship&lt;/h1&gt;
&lt;p&gt;讓我們先從一個簡單的例子Todo list開始，假設我們應用程式有使用者，每個使用者有多個Todo，就這麼簡單的一個one-to-many relationship．&lt;/p&gt;

&lt;h2 id=&quot;relational-dbms&quot;&gt;Relational DBMS&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/data-model-1.jpg&quot; alt=&quot;database relationship&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上圖， 一般使用SQL database的做法，會開兩個table，分別是users及todos，並且在todos table有個欄位user_id為foreign key指到user table&lt;/p&gt;

&lt;h2 id=&quot;document-database&quot;&gt;Document database&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/data-model-2.jpg&quot; alt=&quot;document in NoSQL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在document database中，我們可以將整個資訊存成一個JSON document如上圖，當我們的UI需要呈現某使用者的todo的時候，資料庫只需要一個disk seek就可以拿到全部的資料，對比於relational database，必須在todos table裡找到相對應的rows，再將其與users的row合併．&lt;/p&gt;

&lt;p&gt;可以看到document database用來model one-to-many relationship的資料可說是天生的適合．&lt;/p&gt;

&lt;h1 id=&quot;many-to-one-and-many-to-many-relationship&quot;&gt;Many-to-one and Many-to-many relationship&lt;/h1&gt;

&lt;p&gt;現在假設我們要加入新的功能，使用者可以新增標籤，並把自己的Todo加上一個標籤．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/data-model-3.jpg&quot; alt=&quot;Many-to-many relationship&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Relational database按照normalization的做法，就是再多一個tags table，user_id指向Users，而Todos再多一個foreign key指向Tags，如上圖沒什麼問題．&lt;/p&gt;

&lt;p&gt;而Document database則會向下圖這樣:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/data-model-4.jpg&quot; alt=&quot;document in NoSQL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;資訊重複出現了好幾個地方，容易造成不一致，比如說我想把Coding改成Programming，除了在tags這個array裡面要修改之外，兩個todo裡的tag也要同時修改才行．&lt;/p&gt;

&lt;h2 id=&quot;document-database就不能做normalization嗎&quot;&gt;Document database就不能做normalization嗎？&lt;/h2&gt;
&lt;p&gt;當然是可以的！分別儲存三種類型的document: User、Tag、Todo，當某個user要取得他的資料時，就必須分別從三類document找出相對的document，在合併起來．&lt;/p&gt;

&lt;p&gt;那這跟relational database的join有什麼不一樣嗎？&lt;/p&gt;

&lt;p&gt;其實本質上是一樣的！只不過使用relational database時是database幫你做，而使用document database則是要在application code上面自己做，除了會有更多的network round trip time之外，relational database通常也會幫你優化．&lt;/p&gt;

&lt;h1 id=&quot;schema-flexibility&quot;&gt;Schema flexibility&lt;/h1&gt;
&lt;p&gt;另外他們倆之間常被討論到的不同，就是schema的有無，雖然說document database可以讓你隨意的放入任何的JSON document，但我們通常不會這樣做，一般來說都會把相同類型，有ㄧ樣資料格式的document放在一起，只不過資料庫本身並不會強迫每個document的schema要一模一樣．&lt;/p&gt;

&lt;p&gt;這樣的彈性，讓schema evolution也算方便，資料庫裡可以同時保有舊有的資料和新的資料 ，比如說todo想要新增一個欄位created_at，或是todo原本只能有一個tag，用一個string來表示，現在想要改成可以有多個tag，新新增的資料不在是一個string而是一個array．&lt;/p&gt;

&lt;p&gt;但如此一來application programmer在使用document database時，就不能保證拿到的資料的格式，會出現類似這樣的code:&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;todo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;todo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;created_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;todo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;todo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;時間久了，資料可能會越來越亂，一不注意就跑出個error:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cannot read property ‘some_field’ of undefined!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;該如何管理schema evolution，不讓你的應用程式crash，隨著新功能及新資料的加入能夠compatible，繼續穩定的運行就是另一門學問，有機會可以再來探討．&lt;/p&gt;

&lt;h1 id=&quot;whats-the-situation-preferring-to-schema-less-approach&quot;&gt;What’s the situation preferring to schema-less approach?&lt;/h1&gt;
&lt;p&gt;其實能有schema最好就有，他是你的資料的一個documentation，一個contract，讓programmer寫起程式來更有信心，不用擔心東擔心西，擔心會不會少了個欄位就讓我的process crash掉，那有什麼樣的情況會更適合使用document database嗎？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;資料來自外部，格式不是妳能控制的&lt;/li&gt;
  &lt;li&gt;有非常多種類的object，分別將每個object放到個別的table可能不太適合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如說event sourcing的架構，每種event type都有各自的資料格式，放在relation database的一個table，會有很多欄位是空的，schema定義起來也會非常麻煩．&lt;/p&gt;

&lt;p&gt;再來你的資料來源可能來自爬蟲、外部的API，格式可能改變，所以可以在拿到資料的時候就先存起來，之後讀的時候做處理，不然可能就會丟失部分的資料了．&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;如果你的資料之間的關係不複雜，基本上是one-to-many的，一個self-contained的JSON document能夠包含所有需要的資料，那麼document based的DBMS就相當適合，會有更好的performance，因為資料都在一起．&lt;/p&gt;

&lt;p&gt;Relational database更適合當你的資料之間的關係複雜，有許多many-to-one、many-to-many relationship時，幫你處理join的動作，雖說使用document database也是可以如此，但join的動作必須在application code上執行．&lt;/p&gt;

&lt;p&gt;另外document database也提供更彈性的schema，當你的應用需要面對許多不同且不確定、不是自己能控制的資料格式時，document database也許會有更好的support．&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321&quot;&gt;Designing Data-Intensive Applications Chapter 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://martinfowler.com/articles/schemaless/&quot;&gt;https://martinfowler.com/articles/schemaless/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>HoMuChen</name></author><category term="Web Development" /><category term="data model" /><category term="system design" /><category term="database" /><summary type="html">開發應用程式時，時常使用到資料庫，儲存資料並在之後需要時將其取出，如今有許多的資料庫產品可供選擇，提供各種不同的data model及function，在各種使用情境下有不同的表現，開發者根據你的應用程式的需求、資料之間的關係、access pattern、scalability、ACID transaction、fault-tolerance、會有各種不同的適合的選擇．</summary></entry><entry><title type="html">如何用create-react-app開發，整合一個或多個API backend server</title><link href="https://homuchen.com/posts/create-react-app-integrate-multiple-api-backend-servers/" rel="alternate" type="text/html" title="如何用create-react-app開發，整合一個或多個API backend server" /><published>2020-08-22T20:00:00+08:00</published><updated>2020-08-22T20:00:00+08:00</updated><id>https://homuchen.com/posts/create-react-app-integrate-multiple-api-backend-servers</id><content type="html" xml:base="https://homuchen.com/posts/create-react-app-integrate-multiple-api-backend-servers/">&lt;p&gt;在開發single page application時，會需要透過api來取得及操作資料，本篇文章將示範如何在使用create-react-app開發時，整合一個甚至是多個backend api server！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/cra-1.jpg&quot; alt=&quot;create-react-app with multiple backend servers&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;create-react-app&quot;&gt;Create-react-app&lt;/h1&gt;
&lt;p&gt;使用create-react-app時，簡單一個指令npm start 就可以開始開發，此時CRA會起一個webpack dev server來serve static files，通常我們會想要做類似這樣的動作: fetch(‘/todos’) 、fetch(‘/api/todos’) 來跟我們的API server通訊，此時該如何讓CRA的dev server將request proxy到我們想要的API server呢？&lt;/p&gt;

&lt;h1 id=&quot;透過packagejson&quot;&gt;透過package.json&lt;/h1&gt;
&lt;p&gt;最簡單的方法就是在package.json中加一個proxy欄位，”proxy”: “http://localhost:5000” ，如此一來，所有的request便會被proxy到http://localhost:5000．&lt;/p&gt;

&lt;h2 id=&quot;想解決的問題&quot;&gt;想解決的問題&lt;/h2&gt;
&lt;p&gt;這樣的做法很簡單但卻不太彈性，通常我們會希望外部的資源可以透過環境變數去控制，而不是寫死在檔案裡面，同一份codebase，透過設置不同的環境變數擁有不同的部署，可能是開發環境、測試環境、或staging、production環境 (https://12factor.net/codebase) ．&lt;/p&gt;

&lt;p&gt;另外將proxy寫在package.json中，只能將所有的ajax導到同一個server，假如您是service oriented architecture或microservices這種架構，可能會有許多的服務，例如data api、search api、authentication api、payment api等等．那該如何將不同的path，例如/api、/search、/auth，route到各自的服務呢？&lt;/p&gt;

&lt;h1 id=&quot;透過setupproxyjs&quot;&gt;透過setupProxy.js&lt;/h1&gt;
&lt;p&gt;首先需要安裝dependency&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;npm i -D http-proxy-middleware
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著在src資料夾裡新增一個檔案setupProxy.js，範例如下:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createProxyMiddleware&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;http-proxy-middleware&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;API_HOST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;API_HOST&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SEARCH_HOST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;SEARCH_HOST&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AUTH_HOST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;AUTH_HOST&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/api&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;createProxyMiddleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;API_HOST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  
  &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/search&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;createProxyMiddleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SEARCH_HOST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  
  &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/auth&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;createProxyMiddleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AUTH_HOST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;changeOrigin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如此一來，就能透過環境變數API_HOST、SEARCH_HOST、AUTH_HOST來指向你的服務，變且成功整合多個服務囉！&lt;/p&gt;</content><author><name>HoMuChen</name></author><category term="Web Development" /><category term="react" /><category term="create-react-app" /><summary type="html">在開發single page application時，會需要透過api來取得及操作資料，本篇文章將示範如何在使用create-react-app開發時，整合一個甚至是多個backend api server！</summary></entry><entry><title type="html">[Networking]Application Layer Overview，什麼是Socket?</title><link href="https://homuchen.com/posts/networking-application-layer-overview-what-is-socket/" rel="alternate" type="text/html" title="[Networking]Application Layer Overview，什麼是Socket?" /><published>2020-05-05T20:00:00+08:00</published><updated>2020-05-05T20:00:00+08:00</updated><id>https://homuchen.com/posts/networking-application-layer-overview-what-is-socket</id><content type="html" xml:base="https://homuchen.com/posts/networking-application-layer-overview-what-is-socket/">&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/app-layer-1.jpg&quot; alt=&quot;application layer&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;process-communication&quot;&gt;Process communication&lt;/h1&gt;
&lt;p&gt;上次講過了網路的分層架構之後，接下來要來關注application layer，這一層就是我們應用程式所在的地方，應用程式可能是網頁瀏覽器、電子信箱、Skype等等，每種不同的應用程式會有他們自己的通訊協定，規定應用程式之間該如何交換資料，以及資料的格式，常見的協定例如是HTTP、FTP、DNS等等．&lt;/p&gt;

&lt;p&gt;那application layer的process們之間要怎麼互相通訊呢？就是要利用transport layer所提供的服務．&lt;/p&gt;

&lt;h1 id=&quot;what-is-socket&quot;&gt;What is socket?&lt;/h1&gt;
&lt;p&gt;Application layer的process必須使用transport layer所提供的服務來進行通訊，而這之間的介面就是socket，process只要把資料寫入socket，另一個process從socket讀出資料就好，就是這麼簡單～至於資料是如何在這之間傳遞的，底下的每一層 (transport、network、link、physical layer) 都幫你處理的好好的了，applications就只需要專心做自己的事就好！&lt;/p&gt;

&lt;p&gt;不過在通信之前，必須要知道對方在哪裡，資料才有辦法送到，一個socket就是一組ip:port pair，ip用來分別process所在的機器，而一台機器上會有許多的process，port number則用來分別是想要跟哪個程序溝通，有些服務基本上監聽在一些固定的port上，方便client來連，例如HTTP使用80、FTP用21、SSH使用22等等．&lt;/p&gt;

&lt;p&gt;另外當client要向server通訊時，作業系統會隨機指定一個port給他，如此一來server才會知道訊息要回傳到哪裡．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/app-layer-2.jpg&quot; alt=&quot;application layer&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;transport-layer-service&quot;&gt;Transport layer service&lt;/h1&gt;
&lt;p&gt;Application programer可以根據自己想打造的應用程式的需求，在兩種transport layer所提供的服務中選擇，一個是TCP，另一個是UDP，以下分別介紹．&lt;/p&gt;

&lt;h2 id=&quot;tcp&quot;&gt;TCP&lt;/h2&gt;
&lt;p&gt;TCP提供的是一個可靠的服務，確保資料一定會完整無缺的抵達另一端，使用TCP的application programmer不用擔心資料會到不了另一端，專心於application protocal就好．&lt;/p&gt;

&lt;p&gt;TCP有congestion control的機制，當網路變得壅塞的時候，會放慢sender的速度，這是為整個網路著想的設計，但對於application並沒有直接的幫助，可能還會使得速度變慢．&lt;/p&gt;

&lt;h2 id=&quot;udp&quot;&gt;UDP&lt;/h2&gt;
&lt;p&gt;UDP的服務並不可靠，也就是並不保證資料一定會送達，對於一些應用來說或許是可以接受的，比如即時的通話或視訊，上一秒的聲音或畫面不見就不見了．是ok的．&lt;/p&gt;

&lt;p&gt;另外UDP也沒有flow control跟congestion control，sender想送多快就多快，所以如果有application覺得TCP做太多事了，開發起來綁手綁腳，想要看短的latency，就可以考慮使用TCP，例如google的QUIC就是基於UDP上，再重新自己實現了可靠的傳輸．&lt;/p&gt;

&lt;h1 id=&quot;socket-programming&quot;&gt;Socket programming&lt;/h1&gt;
&lt;p&gt;之後會寫一篇使用Node.js的net module來實際地使用一下TCP的服務，並在這之上打造自己的application protocol，待續…&lt;/p&gt;

&lt;h1 id=&quot;application-layer-protocols&quot;&gt;Application layer protocols&lt;/h1&gt;
&lt;p&gt;接著也會陸續會介紹一些常用的application layer的protocol: HTTP、SMTP、DNS，待續…&lt;/p&gt;</content><author><name></name></author><category term="Networking" /><category term="linux" /><category term="socket" /><category term="tcp" /><category term="udp" /><summary type="html"></summary></entry><entry><title type="html">[Networking]什麼是網路？網路的組成及網路服務供應商 ISP</title><link href="https://homuchen.com/posts/what-is-networking-and-isp/" rel="alternate" type="text/html" title="[Networking]什麼是網路？網路的組成及網路服務供應商 ISP" /><published>2020-04-04T20:00:00+08:00</published><updated>2020-04-04T20:00:00+08:00</updated><id>https://homuchen.com/posts/what-is-networking-and-isp</id><content type="html" xml:base="https://homuchen.com/posts/what-is-networking-and-isp/">&lt;p&gt;網路，可能是人類最大的工程成就之一，如今有數十億的人透過網路連接，在幾秒鐘之內就能夠互相通訊、完成某種任務，各種裝置互相連結，包括伺服器，個人桌上型電腦、平板、手機、未來還會有更多樣的things加入，例如車子、家電、各種感測器 ，等等．如此巨大的工程，大規模的全世界的共同合作，到底是如何做到的？工程架構的決定、協議的制定都值得去借鏡學習．&lt;/p&gt;

&lt;h1 id=&quot;網路的組成&quot;&gt;網路的組成&lt;/h1&gt;

&lt;p&gt;網路連接了世界上數十億的裝置，這些連上網路的裝置就稱為hosts, end-systems，而網路本身由communocation links及packets switches組成，links就是指電話線呀、同軸電纜、光纖、電磁波頻譜這些實際傳送資料的媒介，而資料從一個host到另一個host是被拆分成許多一個一個的packet，藉由link傳送，到達packets switches，每個switch則負責把packet從進來的link選擇一個link傳出去，最後到達目的地．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/isp-2.jpg&quot; alt=&quot;networking&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那到底是誰提供這些links及switches給我們的裝置去連接上呢？就是網際網路服務供應商，Internet Service Provider，ISP．&lt;/p&gt;

&lt;h1 id=&quot;internet-service-providerisp&quot;&gt;Internet Service Provider(ISP)&lt;/h1&gt;

&lt;p&gt;在台灣，當我們想要使用網路時，就要去找中華電信、遠傳、台灣大哥大等等的電信商，他們就是ISP，負責建設基礎設施，設定連結，我們透過行動網路、光纖、DSL連上，網路供應商的設備就會負責傳遞資料來往於我們與目的地之間．&lt;/p&gt;

&lt;p&gt;比如A跟B都去了中華電信申請了網路服務，連接上後A及B之間就能互相通訊了，那現在C使用了遠傳的服務，AB及C該要怎麼通訊呢?如果中華電信跟遠傳之間互相連接起來就可以了．&lt;/p&gt;

&lt;p&gt;那全球有那麼多的用戶，各自使用各自的服務供應商，如果全部都必須要能夠互相通訊，就必須要全部的網路服務供應商都互相連接才行，但這要有點太不實際了，連結的數量太過龐大，成本非常高．&lt;/p&gt;

&lt;p&gt;現在假設有個全球範圍的服務供應商，各地區的供應商只要接上去就可以了，下層的服務供應商成了上層的客戶，依據流量付費，有錢賺的生意當然就有許多人進來做，許多競爭的供應商加入，彼此也可以互相連結，客戶也可以跟多個供應商合作，如此當有任一供應商服務中斷，也不會影響終端用戶．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/isp-3.jpg&quot; alt=&quot;networking&quot; /&gt;&lt;/p&gt;

&lt;p&gt;於是網路就成了階層式的架構，上下層的客戶關係，同層之間也會互相連接，各個供應商自己負責建設自己的基礎設施及設定路由，封包的傳送可能會有經濟的考量(盡量不走上層供應商，因為要錢，只在同層之間交換)、或者是政治考量(不想封包經過某某國家的設備，或是所以封包都要經過某地，以利監控、阻擋某些來源)．&lt;/p&gt;</content><author><name>HoMuChen</name></author><category term="Networking" /><category term="networking" /><category term="ISP" /><summary type="html">網路，可能是人類最大的工程成就之一，如今有數十億的人透過網路連接，在幾秒鐘之內就能夠互相通訊、完成某種任務，各種裝置互相連結，包括伺服器，個人桌上型電腦、平板、手機、未來還會有更多樣的things加入，例如車子、家電、各種感測器 ，等等．如此巨大的工程，大規模的全世界的共同合作，到底是如何做到的？工程架構的決定、協議的制定都值得去借鏡學習．</summary></entry><entry><title type="html">[Networking] 網路的架構，Layered Architecture</title><link href="https://homuchen.com/posts/networking-layered-architecture/" rel="alternate" type="text/html" title="[Networking] 網路的架構，Layered Architecture" /><published>2020-04-04T20:00:00+08:00</published><updated>2020-04-04T20:00:00+08:00</updated><id>https://homuchen.com/posts/networking-layered-architecture</id><content type="html" xml:base="https://homuchen.com/posts/networking-layered-architecture/">&lt;p&gt;網路是個如此巨大的工程，要如何架構，才能讓全世界的人通力合作，一起打造這豐富的世界呢？答案就是Layered Artichecture ．&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;layered-architecture&quot;&gt;Layered Architecture&lt;/h1&gt;
&lt;p&gt;網路的最終目的，就是讓兩個執行在不同機器的程式可以互相溝通、交換資料，例如你的瀏覽器chrome跟網頁伺服器溝通，你手機的Skype跟另一個人的Skype溝通，而這中間，資料經過了重重難關、無數的機器及路由器，這麼多的機器到底是如何一起合作的呢？&lt;/p&gt;

&lt;p&gt;答案就是分層的架構，Layered Architecture，生活中很多地方都可以看到類似的架構，我們以公司內部的信件為例好了，假設現在有一間公司有ABC三間分公司，在A公司的Alice想要寄封信給B公司的Bob，Alice首先寫了信的內容，將之放入信封內，並寫上收件人: B公司的bob，之後將信封交給A公司裡的一個叫做信件部門的部門，信件部門將信封寫上B公司的地址，再將信封交給附近的郵局，而郵局則使用卡車、飛機等運輸工具將信封運到B公司附近的郵局，此郵局再送到B公司，最後B公司的信件部門收到信，將他交給Bob．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/layered-arc-1.jpg&quot; alt=&quot;Layered Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分層架構將一項任務分成了許多層，每一層只專心做自己的事，並且使用下一層所提供的服務．&lt;/p&gt;

&lt;p&gt;例如上圖中，人這一層，只專心將內容寫入信中，放進信封袋裡，然後交給下一層的信件部門就好，人這一層使用了信件部門這一層提供的服務，完全無需去擔心這封信最後是如何抵達另一個人那邊去，而信件部門層則使用郵局提供的服務，郵局服務提供了公司的工司的寄送，而信件部門就只專心將信件交給公司裡的某某人．&lt;/p&gt;

&lt;h1 id=&quot;layers-in-the-internet&quot;&gt;Layers in the Internet&lt;/h1&gt;
&lt;p&gt;網路世界的分層如下圖，根據OSI Model應該是有七層，但就目前常用，只介紹此五層，Application layer、Transmission layer、Network layer、Link layer、Physical layer．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/layered-arc-2.jpg&quot; alt=&quot;Layered Architecture&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;application-layer&quot;&gt;Application layer&lt;/h2&gt;
&lt;p&gt;這裡就是我們的應用程式所在地方，根據你的程式所要達成的目的，各自執行著自己的協議．例如網頁瀏覽器跟伺服器，一個說給我看某某網頁首頁，伺服器就說，好！給你！這之間資料交換的格式及方法，就是由HTTP協議所規範，只要瀏覽器跟伺服器都遵守HTTP的規範就能互相溝通．電子信箱服務使用的則是SMTP，查詢網域ip位置的是DNS，傳輸檔案的FTP等等．&lt;/p&gt;

&lt;p&gt;而所有的application都必須依賴使用下層transmission layer的服務，transmission laye會負責applications之間的通訊，application只需要相信transmission layer會將信息傳遞給另一個application，專心做自己的事就好！&lt;/p&gt;

&lt;h2 id=&quot;transmission-layer&quot;&gt;Transmission layer&lt;/h2&gt;
&lt;p&gt;Transmission layer protocol負責傳遞信息於application之間，一台機器上可能有多個application，而transmission layer protocol則是用port number來分辨到底目標是哪個process．&lt;/p&gt;

&lt;p&gt;目前網路世界中有兩種Transmission layer protocol，分別是TCP及UDP，TCP提供的服務保證資料一定會完整無誤地抵達目的地，並且還有flow control及congestion control．而UDP則沒做這麼多事，資料可能會丟失．&lt;/p&gt;

&lt;h2 id=&quot;network-layer&quot;&gt;Network layer&lt;/h2&gt;
&lt;p&gt;每台連上網路的機器都會有個地址，有就是IP位址，Network layer中的唯一一個protocol就是IP protocol，負責將資料從一個IP送到另一個IP，也就是從一台host到另一台host！這之間會經過許多的router，每個執行IP protacol的router會決定要將封包傳遞給哪下一個router來抵達目的地，但並不保證封包一定會抵達．&lt;/p&gt;

&lt;h2 id=&quot;link-layer&quot;&gt;Link layer&lt;/h2&gt;
&lt;p&gt;以上兩層當web dev以來，也從來沒碰過，哈！不熟，如果有興趣的人在自己去找資料囉～&lt;/p&gt;

&lt;h2 id=&quot;physical-layer&quot;&gt;Physical layer&lt;/h2&gt;
&lt;p&gt;這邊就是訊息從0101的bits轉換成真正物理世界裡存在的傳播媒介的地方了，可能是電磁波四處亂射，也可以是光走在光纖裡，或是電走在電線裡．&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;為了讓兩個在不同host上的process能夠通訊，首先你要指出你想要的通訊的process在什麼地方，透過ip:port這個pair，network layer會負責將信息送到擁有這個ip的機器，但卻不保證資料不會丟失，而network layer則透過port知道要將資料傳給哪個process，並且如果是TCP的話，會保證資料完好無缺地抵達另一個process那邊 (TCP可靠的傳輸建立在不可靠的IP上，酷吧！)，最後application根據自己的邏輯，來決定資料的格式，如何及何時發送和接收．&lt;/p&gt;</content><author><name>HoMuChen</name></author><category term="Networking" /><category term="networking" /><category term="layered architecture" /><summary type="html">網路是個如此巨大的工程，要如何架構，才能讓全世界的人通力合作，一起打造這豐富的世界呢？答案就是Layered Artichecture ．</summary></entry></feed>