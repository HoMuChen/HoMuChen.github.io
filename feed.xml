<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-tw"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://homuchen.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://homuchen.com/" rel="alternate" type="text/html" hreflang="zh-tw" /><updated>2021-07-14T17:14:34+08:00</updated><id>https://homuchen.com/feed.xml</id><title type="html">HoMuChen</title><subtitle>Hi! This is HoMuchen, 陳河穆. I am a software engineer working at Largitdata now. This is where I record whatever I learned.</subtitle><entry><title type="html">[讀書筆記] 最高學以致用法: 讓學習發揮最大成果的輸出大全</title><link href="https://homuchen.com/posts/book-notes-output/" rel="alternate" type="text/html" title="[讀書筆記] 最高學以致用法: 讓學習發揮最大成果的輸出大全" /><published>2021-07-14T17:10:00+08:00</published><updated>2021-07-14T17:10:00+08:00</updated><id>https://homuchen.com/posts/book-notes-output</id><content type="html" xml:base="https://homuchen.com/posts/book-notes-output/">&lt;p&gt;不知道大家是否有過這樣的經驗: 讀了許多本書，事後卻說不出來到底讀了什麼;
看了一場電影、經歷一趟旅程，卻分享不出想法、或是說出從中有哪些收穫．&lt;/p&gt;

&lt;p&gt;大家可能也有聽過，最好的學習方法就是去教人．&lt;/p&gt;

&lt;p&gt;教學就是一種輸出，本書作者認為自我成長的關鍵就是&lt;strong&gt;輸出&lt;/strong&gt;，於本書收集了80個關於說、寫、行動三個面向的輸出，
每一則皆為兩到三分鐘的時間就能閱讀完的份量，讓我們在自己的日常生活中尋找幾個可以小小進步的地方!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/reading-output-1.jpg&quot; alt=&quot;最高學以致用法: 讓學習發揮最大成果的輸出大全&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;原則&quot;&gt;原則&lt;/h1&gt;

&lt;p&gt;此書的第一部分說明一些原則: 為什麼要輸出、什麼是輸出、輸入輸出的比例多少為好、以及除了輸出之外還需要些什麼?&lt;/p&gt;

&lt;h2 id=&quot;自我成長及改變生活的關鍵&quot;&gt;自我成長及改變生活的關鍵&lt;/h2&gt;

&lt;p&gt;想讓自己成長得更快，重點不是多讀了多少書，關鍵是更多的輸出！透過分享、書寫、實踐，讓自己的記憶更加牢固，
不管讀了多少書、上了多少課，如果沒有輸出實踐，不僅僅只是忘光光沒有記住而已，你的生活並不會有任何的改變&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;唯一可以改變現實的就是你的行為實踐&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;兩週內運用三次&quot;&gt;兩週內運用三次&lt;/h2&gt;

&lt;p&gt;情報及知識輸入到大腦裡，如果沒有經常運用很快就會忘記&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;透過反覆三次的輸出，讓情報成為長期記憶，儲存在大腦裡．&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;輸入輸出比37&quot;&gt;輸入輸出比3:7&lt;/h2&gt;

&lt;p&gt;有一個實驗是這樣子的，讓一群人去背社交名人錄的資訊，並依照不同的&lt;strong&gt;記憶時間&lt;/strong&gt;，&lt;strong&gt;測驗時間&lt;/strong&gt;，來看看最後誰的成績最好，
結果發現最後成績最高的，是花了40%時間在學習的組別，年紀越大的則是30%&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;輸入和輸出的黃金比例，應該是3:7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;輸出之外還要有反饋&quot;&gt;輸出之外還要有反饋&lt;/h2&gt;

&lt;p&gt;單純不斷地輸入輸出，雖然也會有收穫，但如果沒有反饋就難以進步，有了反饋可以更知道下一次輸入的方向&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;補足弱點、發揮強項:&lt;/p&gt;

    &lt;p&gt;在輸出的同時，可以知道哪部分不夠清楚，再回頭去補強輸入，複習或是尋找相關資料，
另外對於自己有&lt;strong&gt;興趣&lt;/strong&gt;的部分，能夠做延伸學習～&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解決&lt;strong&gt;為什麼&lt;/strong&gt;們:&lt;/p&gt;

    &lt;p&gt;在輸入輸出的過程中，一定會產生很多的疑問，不要放著這些為什麼不管，解決這些為什麼!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;實踐&quot;&gt;實踐&lt;/h1&gt;

&lt;p&gt;分為說、寫、行動這三大類，作者整理了80個跟輸出有關的事，以下簡單地列舉一部分:&lt;/p&gt;

&lt;h2 id=&quot;說&quot;&gt;說&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;分享前一天的事、體驗、感受&lt;/li&gt;
  &lt;li&gt;說正面而不是負面&lt;/li&gt;
  &lt;li&gt;非語言的表達的重要: 語調、表情、姿勢、肢體、動作&lt;/li&gt;
  &lt;li&gt;委婉地表達&lt;/li&gt;
  &lt;li&gt;關於提問、讚美、斥責、道歉、感謝&lt;/li&gt;
  &lt;li&gt;如何提問&lt;/li&gt;
  &lt;li&gt;關於簡報、打電話&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;寫&quot;&gt;寫&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;寫下來～ 而且用手寫&lt;/li&gt;
  &lt;li&gt;關於做筆記、寫摘要&lt;/li&gt;
  &lt;li&gt;列出清單&lt;/li&gt;
  &lt;li&gt;彙整想法&lt;/li&gt;
  &lt;li&gt;製作企劃&lt;/li&gt;
  &lt;li&gt;引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;行為&quot;&gt;行為&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如何採取行動、並持之以恆&lt;/li&gt;
  &lt;li&gt;笑、哭&lt;/li&gt;
  &lt;li&gt;關於睡覺、運動&lt;/li&gt;
  &lt;li&gt;如何寫感想&lt;/li&gt;
  &lt;li&gt;社群、部落格&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;心得感想&quot;&gt;心得感想&lt;/h1&gt;

&lt;p&gt;讀完這本書之後，意識到原來生活當中，有如此多的面相都是輸出，
而不是原本以為的發表演說、報告、寫文章而已．&lt;/p&gt;

&lt;p&gt;但就像這本書的主題&lt;strong&gt;輸出&lt;/strong&gt;，如果沒有加以實踐，就不會有收穫，
這也是我會開始寫這篇文章的原因，並且開始規定自己在輸出完一本書之前，不能再繼續讀下一本😂
希望這讀書筆記系列可以持之以恆下去!&lt;/p&gt;

&lt;p&gt;也希望以上的內容，能稍微幫助到想認識這本書的人！掰掰～👋&lt;/p&gt;</content><author><name>HoMuChen</name></author><category term="讀書筆記" /><category term="learning" /><category term="writing" /><category term="books" /><summary type="html">不知道大家是否有過這樣的經驗: 讀了許多本書，事後卻說不出來到底讀了什麼; 看了一場電影、經歷一趟旅程，卻分享不出想法、或是說出從中有哪些收穫．</summary></entry><entry><title type="html">[Google sheet]我如何製作股票損益表，自動抓取最新股價</title><link href="https://homuchen.com/posts/google-sheet-stock-income-statement/" rel="alternate" type="text/html" title="[Google sheet]我如何製作股票損益表，自動抓取最新股價" /><published>2021-07-09T16:30:00+08:00</published><updated>2021-07-09T16:30:00+08:00</updated><id>https://homuchen.com/posts/google-sheet-stock-income-statement</id><content type="html" xml:base="https://homuchen.com/posts/google-sheet-stock-income-statement/">&lt;p&gt;此篇文章將分享我是如何製作我持有股票的未實現損益表，看起來的成果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/income-statement-1.jpg&quot; alt=&quot;google sheet: stock income statement&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;主要功能&quot;&gt;主要功能&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;自動更新股價&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;根據最新股價，計算損益，並以顏色區分損或益&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;近一年的股價折線圖&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;step-by-step&quot;&gt;Step by Step&lt;/h1&gt;

&lt;h2 id=&quot;製作表格&quot;&gt;製作表格&lt;/h2&gt;

&lt;p&gt;首先填入表頭欄位，在這裡我們會有:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;股票代號&lt;/strong&gt;、&lt;strong&gt;名稱&lt;/strong&gt;、&lt;strong&gt;近一年股價&lt;/strong&gt;、&lt;strong&gt;現價&lt;/strong&gt;、&lt;strong&gt;漲跌&lt;/strong&gt;、
&lt;strong&gt;成交量&lt;/strong&gt;、&lt;strong&gt;持有張數&lt;/strong&gt;、&lt;strong&gt;市值&lt;/strong&gt;、&lt;strong&gt;持有成本&lt;/strong&gt;、&lt;strong&gt;損益&lt;/strong&gt;、&lt;strong&gt;損益百分比&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/income-statement-2.jpg&quot; alt=&quot;google sheet: blank data table&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每新增一檔股票，需要我們自己填入的有&lt;strong&gt;股票代號&lt;/strong&gt;、&lt;strong&gt;名稱&lt;/strong&gt;，&lt;strong&gt;持有張數&lt;/strong&gt;、&lt;strong&gt;持有成本&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;股票代號&lt;/strong&gt;: 爲後續&lt;strong&gt;GOOGLEFINANCE&lt;/strong&gt;函式的參數，這裡以台北股市台積電為例爲TPE:2330&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;名稱&lt;/strong&gt;: 就你自己開心如何稱這黨股票就好～&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;持有張數&lt;/strong&gt;: 就是你的持有張數…&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;持有成本&lt;/strong&gt;: 每次買股票時，就將成本加上去吧&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;取得最新股價資訊現價成交量計算市值&quot;&gt;取得最新股價資訊(現價、成交量)，計算市值&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;現價&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;使用&lt;strong&gt;GOOGLEFINANCE&lt;/strong&gt;函式來取得股價資訊！&lt;/p&gt;

    &lt;p&gt;在D2儲存格中輸入公式: &lt;strong&gt;=GOOGLEFINANCE(A2, “price”)&lt;/strong&gt;，之後下來套用至整個D欄
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/income-statement-3.jpg&quot; alt=&quot;google sheet: GOOGLEFINANCE price&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;成交量&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;=GOOGLEFINANCE(A2, “volume”)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;市值&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;將&lt;strong&gt;持有張數&lt;/strong&gt;及&lt;strong&gt;現價&lt;/strong&gt;相乘即可～ &lt;strong&gt;=D2*G2&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;計算當日漲跌損益&quot;&gt;計算當日漲跌損益&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;漲跌&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;有了現價，可以跟昨日收盤價做比較計算出今日漲跌: &lt;strong&gt;=D2 - GOOGLEFINANCE(A2, “closeyest”)&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/income-statement-4.jpg&quot; alt=&quot;google sheet: GOOGLEFINANCE closeyest&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;損益&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;即為&lt;strong&gt;持有成本&lt;/strong&gt;及&lt;strong&gt;市值&lt;/strong&gt;相減: &lt;strong&gt;=H2-I2&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;損益百分比&lt;/strong&gt;:&lt;/p&gt;

    &lt;p&gt;即為&lt;strong&gt;損益&lt;/strong&gt;除以&lt;strong&gt;持有成本&lt;/strong&gt;: &lt;strong&gt;=IF(ISBLANK(I2), 0, J2/I2)&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/income-statement-5.jpg&quot; alt=&quot;google sheet: GOOGLEFINANCE&quot; /&gt;
&lt;strong&gt;IF&lt;/strong&gt;及&lt;strong&gt;ISBLANK&lt;/strong&gt;的用途爲如果你尚未實有該檔股票，持有成本爲0或空白，卻又寫列入表中觀察，
則&lt;strong&gt;損益百分比&lt;/strong&gt;顯示為0，否則將出現錯誤．&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;股價折線圖&quot;&gt;股價折線圖&lt;/h2&gt;

&lt;p&gt;公式為: &lt;strong&gt;=sparkline(GOOGLEFINANCE(A2, “price”,today()-365,today(),1))&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/income-statement-6.jpg&quot; alt=&quot;google sheet: GOOGLEFINANCE sparkline&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GOOGLEFINACE:
總共四個參數，第一為股票代號、再來是起始日期跟結束日期，此範例使用一年前today()-365到今天today()、最後爲資料的interval，
1代表每天，也可以是7代表每週&lt;/li&gt;
  &lt;li&gt;sparkline:
可以再一個儲存格裡畫圖的函式，詳細的用法可以看我先前寫的文章:&lt;a href=&quot;/posts/google-sheet-sparkline/&quot;&gt;[Google Sheet]Sparkline，在儲存格裡插入迷你圖表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;替漲跌及損益百分比上色&quot;&gt;替漲跌及損益百分比上色&lt;/h2&gt;

&lt;p&gt;最後！股市就是要紅紅綠綠才比較好看，將賺錢的部分標上紅色，虧錢的弄上綠色吧！&lt;/p&gt;

&lt;p&gt;首先點選漲跌那一欄(E)，接著點選工具欄&lt;strong&gt;格式&lt;/strong&gt; -&amp;gt; &lt;strong&gt;條件格式設定&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/income-statement-7.jpg&quot; alt=&quot;google sheet: format&quot; /&gt;&lt;/p&gt;

&lt;p&gt;將格式規則設為大於0，格式設定樣式改為字體紅色，綠色及損益率的部分也是一樣！
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/income-statement-8.jpg&quot; alt=&quot;google sheet: format&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如此一來就大功告成囉🎉&lt;/p&gt;</content><author><name>HoMuChen</name></author><category term="Google Sheet" /><category term="google sheet" /><category term="finanace" /><summary type="html">此篇文章將分享我是如何製作我持有股票的未實現損益表，看起來的成果如下:</summary></entry><entry><title type="html">[Google sheet]如何建立下拉選單，以及從既有資料中自動建立選項</title><link href="https://homuchen.com/posts/google-sheet-create-a-drop-down-list-from-existed-data/" rel="alternate" type="text/html" title="[Google sheet]如何建立下拉選單，以及從既有資料中自動建立選項" /><published>2021-06-26T20:00:00+08:00</published><updated>2021-06-26T20:00:00+08:00</updated><id>https://homuchen.com/posts/google-sheet-create-a-drop-down-list-from-existed-data</id><content type="html" xml:base="https://homuchen.com/posts/google-sheet-create-a-drop-down-list-from-existed-data/">&lt;h1 id=&quot;為什麼要用下拉式選單&quot;&gt;為什麼要用下拉式選單&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;新增資料更為快速，無需重複填寫&lt;/li&gt;
  &lt;li&gt;避免誤植，或統一資料的格式及規則&lt;/li&gt;
  &lt;li&gt;對既有資料鐘進行選擇及後續操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;如何建立下拉式選單&quot;&gt;如何建立下拉式選單&lt;/h1&gt;

&lt;h2 id=&quot;自行輸入清單選項&quot;&gt;自行輸入清單選項&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;首先選擇一個或多個你想要建立選單的儲存格&lt;/li&gt;
  &lt;li&gt;點選 &lt;strong&gt;資料&lt;/strong&gt; -&amp;gt; &lt;strong&gt;資料驗證&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-1.jpg&quot; alt=&quot;data validation: tool bar&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;條件&lt;/strong&gt;選項中，選取&lt;strong&gt;項目清單&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-2.jpg&quot; alt=&quot;data validation: List of items&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;輸入你想要的選項，選項間以逗號隔開
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-3.jpg&quot; alt=&quot;data validation: List of items&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;就大功告成拉
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-4.jpg&quot; alt=&quot;drop down menu&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;從既有資料來建立選項&quot;&gt;從既有資料來建立選項&lt;/h2&gt;

&lt;p&gt;有時你想要建立一個選單，其中的選項是來自某一大筆資料中的某一個欄位，
你不想一筆一筆手動Key，而且你也不想每次資料有變動時，就要重新去更新一次資料驗證，
此時就可以這麼做，以以下的資料為例:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-5.jpg&quot; alt=&quot;example data sheet&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;重複自行輸入清單選項中的第一及第二部&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;條件&lt;/strong&gt;選項中，選取&lt;strong&gt;範圍內的清單&lt;/strong&gt;
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-6.jpg&quot; alt=&quot;data validation: List from a range&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;輸入或選取一個範圍，以這裡的例子為例，我們建立一個國家的下拉選項，填入&lt;strong&gt;F2:F&lt;/strong&gt;，代表country那一欄，不包含標頭country本身&lt;/li&gt;
  &lt;li&gt;大功告成~
&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/drop-down-7.jpg&quot; alt=&quot;drop down menu from a range&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;建立一個下拉選單，選項可以自行輸入，也可以從既有資料的範圍中建立，如此一來當資料有變動時，下拉選單的選項就可以自動更新，而不需要自己再重新輸入新的選項!&lt;/p&gt;</content><author><name>HoMuChen</name></author><category term="Google Sheet" /><category term="google sheet" /><category term="drop down list" /><summary type="html">為什麼要用下拉式選單</summary></entry><entry><title type="html">RESTful API Design — A practical guide</title><link href="https://homuchen.com/posts/http-restful-api-design-practical-guide/" rel="alternate" type="text/html" title="RESTful API Design — A practical guide" /><published>2021-04-13T20:00:00+08:00</published><updated>2021-04-13T20:00:00+08:00</updated><id>https://homuchen.com/posts/http-restful-api-design-practical-guide</id><content type="html" xml:base="https://homuchen.com/posts/http-restful-api-design-practical-guide/">&lt;p&gt;此篇文章將作為接下來一系列關於Restful API design的目錄．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 1:&lt;/strong&gt; 將介紹什麼是API，何時需要他，以及怎樣才會是一個好的API．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 2:&lt;/strong&gt; 在許多種API中，此系列只專注於HTTP RESTful API，為了更好地學習他，必須先了解HTTP Protocol，知道其中各個組成HTTP Message的每一個部分．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 3:&lt;/strong&gt; 介紹何為RESTful API，為什麼他會長這樣，以及其他許多當你在設計API時會遇到情況，例如: Documentation、Pagination、Rate Limiting、Monitoring．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 4:&lt;/strong&gt; 陸續想到一些相關的議題，再放上來！&lt;/p&gt;

&lt;h1 id=&quot;outline&quot;&gt;Outline&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Introduction
    &lt;ul&gt;
      &lt;li&gt;1.1 What is an API?&lt;/li&gt;
      &lt;li&gt;1.2 What is a good API?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP Basics
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;/posts/http-introduction-telnet-nc-curl&quot;&gt;2.1 A HTTP Overview&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/posts/http-methods-which-to-use-and-how-to-use-them-correctly&quot;&gt;2.2 HTTP Methods&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;2.3 HTTP Response codes&lt;/li&gt;
      &lt;li&gt;2.4 HTTP URI&lt;/li&gt;
      &lt;li&gt;2.5 HTTP Headers&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/posts/linux-http-client-tool-curl-usage/&quot;&gt;2.6 [Practices] A HTTP client — curl&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RESTful API and some Practical Guidelines
    &lt;ul&gt;
      &lt;li&gt;3.1 What is a RESTful API?&lt;/li&gt;
      &lt;li&gt;3.2 Identifying Resources&lt;/li&gt;
      &lt;li&gt;3.2 API first&lt;/li&gt;
      &lt;li&gt;3.3 An Introduction to OpenAPI&lt;/li&gt;
      &lt;li&gt;3.4 [Practices] How do I manage a large OpenAPI spec file?&lt;/li&gt;
      &lt;li&gt;3.5 Pagination&lt;/li&gt;
      &lt;li&gt;3.6 Rate Limiting&lt;/li&gt;
      &lt;li&gt;3.7 Monitoring&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Advanced Topics
    &lt;ul&gt;
      &lt;li&gt;4.1 Connection management&lt;/li&gt;
      &lt;li&gt;4.2 Resource Modeling: Fine-grained or Coarse-grained?&lt;/li&gt;
      &lt;li&gt;4.3 Versioning and Compatibility&lt;/li&gt;
      &lt;li&gt;4.4 How to Response to a Health Check?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>HoMuChen</name></author><category term="API Design" /><category term="api" /><category term="http" /><category term="restful api" /><summary type="html">此篇文章將作為接下來一系列關於Restful API design的目錄．</summary></entry><entry><title type="html">What are HTTP Methods？Which to use and How to use them correctly?</title><link href="https://homuchen.com/posts/http-methods-which-to-use-and-how-to-use-them-correctly/" rel="alternate" type="text/html" title="What are HTTP Methods？Which to use and How to use them correctly?" /><published>2021-04-04T20:00:00+08:00</published><updated>2021-04-04T20:00:00+08:00</updated><id>https://homuchen.com/posts/http-methods-which-to-use-and-how-to-use-them-correctly</id><content type="html" xml:base="https://homuchen.com/posts/http-methods-which-to-use-and-how-to-use-them-correctly/">&lt;p&gt;這篇文章主要討論幾個常見的HTTP methods，說明他們分別是否具有哪些特性(Safe、Idempotent)，以及他們應該要怎麼使用，比較會是符合大家的期待．&lt;/p&gt;

&lt;p&gt;當然寫server的人可以不照著慣例走，不過如此一來，使用這個API的user可能會很不高興，而這個user可以是公司的客戶，可能是公司內部的其他團隊，也可能是未來的自己！&lt;/p&gt;

&lt;h1 id=&quot;outline&quot;&gt;Outline&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP Request message格式&lt;/li&gt;
  &lt;li&gt;常見的methods，以及其特性&lt;/li&gt;
  &lt;li&gt;分別介紹各個method的用法&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;http-request-message&quot;&gt;HTTP Request message&lt;/h1&gt;
&lt;p&gt;一個general的HTTP request message如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;method&amp;gt; &amp;lt;URL&amp;gt; &amp;lt;version&amp;gt;
&amp;lt;header&amp;gt;
...
...
&amp;lt;header&amp;gt;

&amp;lt;body&amp;gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一個字就是method，接著為URL跟version，換行後為許多個header，每個header以換行隔開，最後再隔一行之後是body．&lt;/p&gt;

&lt;p&gt;對於HTTP message還不熟的，可以看我之前寫的文章：&lt;a href=&quot;/posts/http-introduction-telnet-nc-curl&quot;&gt;[Networking] HTTP 簡介，以及使用telnet、nc、curl等指令來探索&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;URL代表著資源，而method是你想要對資源進行的操作，常見的method如下表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/header-1.jpg&quot; alt=&quot;http headers&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;dont-surprise-your-user&quot;&gt;Don’t surprise your user&lt;/h1&gt;
&lt;p&gt;並不是所有的server都會實作所有的method，而且每個method要做什麼事，也都是由server所決定的，但是一個好的API通常不會做怪怪的事，而是要符合使用者的期待，使其體驗良好，這裡先來解釋一下safe及Idempotent這兩個特性是什麼吧．&lt;/p&gt;
&lt;h2 id=&quot;safe&quot;&gt;Safe&lt;/h2&gt;
&lt;p&gt;如果一個request是safe的，指的是他不會導致server去做一些額外的動作，沒有side effect，例如說改變state、刷你信用卡，這樣的request基本上就是read-only的．
這樣的特性，使得API的user可以大膽放心地去呼叫，實驗你的API，而不必擔心會引發什麼無法挽回的後果，GET、HEAD、OPTIONS都是具有safe特性的method．&lt;/p&gt;
&lt;h2 id=&quot;idempotent&quot;&gt;Idempotent&lt;/h2&gt;
&lt;p&gt;一個Idempotent的操作，指的是這樣的操作執行一次跟執行很多次的結果是一樣的．例如數學上的乘以1，乘以0，一個是數字乘以1或乘以0不管多少次，結果都是原本的數字或者是0．&lt;/p&gt;

&lt;p&gt;那有Idempotent的特性，可以帶來什麼好處呢？就是user可以放心的retry，當user不確定剛剛的operation、request有沒有成功時(可能送出後網路突然斷掉、server做完之後再回應之前掛掉、等等…)，就再做一次！&lt;/p&gt;

&lt;p&gt;而HTTP method中，除了POST，其他method都預期應該是Idempotent的，Update好幾次，Delete好幾次，應該都跟只做一次的結果一致．&lt;/p&gt;

&lt;h1 id=&quot;http-methods&quot;&gt;HTTP Methods&lt;/h1&gt;
&lt;p&gt;看完了共同的特性之後，接著來看看給個method預期是怎麼使用，以及server如何回應各種情況．&lt;/p&gt;

&lt;h2 id=&quot;get&quot;&gt;GET&lt;/h2&gt;
&lt;p&gt;最常見的method之一，顧名思義就是用來向server索取一些資源．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;有資源，server就回應200以及資源&lt;/li&gt;
  &lt;li&gt;沒有資源，404&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;head&quot;&gt;HEAD&lt;/h2&gt;
&lt;p&gt;跟GET都一樣，但server並不回傳資源本身，而是只回應headers．&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Response&amp;gt;
HTTP/1.1 200 OK
Content-Type: plain/html
Content-Length: 614
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;options&quot;&gt;OPTIONS&lt;/h2&gt;
&lt;p&gt;用來詢問server對特定的資源，有支援哪些操作．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;將結果置於header Allow裡，如下：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Response&amp;gt;
HTTP/1.1 200 OK
Allow: GET, POST, PUT, OPTIONS
Content-Length: 0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;put&quot;&gt;PUT&lt;/h2&gt;
&lt;p&gt;Replace the entire resource，對應到CRUD裡的update，就是叫server將我request body裡的資料存起來，如果資源本來不存在就create，在的話就replace．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200 OK，成功&lt;/li&gt;
  &lt;li&gt;204 No Content，成功但畫面不需要更新，也就是沒有新的資料產生，client不必取的新的資料，例如說client在更新表單按下save時．&lt;/li&gt;
  &lt;li&gt;201 Created，如果是create的話，並且在header Location放上資源的URI
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Response&amp;gt;
HTTP/1.1 201 Created
Location: https://api.example.com/users/123 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;patch&quot;&gt;PATCH&lt;/h2&gt;
&lt;p&gt;Update parts of the resource，跟PUT一樣是update，不過是partial update或者說是merge．
比如說原本有個homuchen的user是長這樣：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
    &quot;name&quot;: &quot;HoMuChen&quot;,
    &quot;age&quot;: 30
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;當你PATCH時，想要將age更新為31&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;Request&amp;gt;
PATCH /users/homuchen HTTP/1.1
Content-Type: application/json
Content-Length: 11

{&quot;age&quot;: 31}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;結果為&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
    &quot;name&quot;: &quot;HoMuChen&quot;,
    &quot;age&quot;: 31
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果是用PUT，則會整個replace掉，name就不見了&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
    &quot;age&quot;: 31
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;post&quot;&gt;POST&lt;/h2&gt;
&lt;p&gt;一般來說是指把資料傳給server去做處理，當使用其他的method，語意無法符合時，就會使用POST，常見的有用於Create resources、Search query、Asynchronous tasks．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200 OK&lt;/li&gt;
  &lt;li&gt;201 Created&lt;/li&gt;
  &lt;li&gt;202 Accepted，server已接受請求，但還需要時間去完成任務．&lt;/li&gt;
  &lt;li&gt;Search Query: Ex. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&quot;&gt;Elasticsearch Query DSL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;delete&quot;&gt;DELETE&lt;/h2&gt;
&lt;p&gt;顧名思義，用來刪除資源．&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200 OK．&lt;/li&gt;
  &lt;li&gt;207，bulk delete．&lt;/li&gt;
  &lt;li&gt;404 Not Found，要刪除的資源不存在．&lt;/li&gt;
  &lt;li&gt;410 Gone，資源已被刪除．&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;HTTP做為網路世界中眾多通訊協定中的一個，只有當我們更加了解他，service provider才能提供更好用、另client user的學習曲線低，用起來很開心的服務．&lt;/p&gt;

&lt;p&gt;今天簡單地討論了各個HTTP Method的用法，每個method有他的語意，只有當server照著大家的預期去做時，才不會造成大家的困擾．&lt;/p&gt;

&lt;p&gt;除了Method之外，還有Response code、Header等其他HTTP的組成需要去了解，最後整個API符合RESTful的style是這一系列文章的目標．&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;感謝大家的閱讀，如有錯誤歡迎指正，我是河穆，我們下次見！&lt;/p&gt;</content><author><name></name></author><category term="API Design" /><category term="restful api" /><category term="api" /><category term="http" /><summary type="html">這篇文章主要討論幾個常見的HTTP methods，說明他們分別是否具有哪些特性(Safe、Idempotent)，以及他們應該要怎麼使用，比較會是符合大家的期待．</summary></entry><entry><title type="html">A Linux HTTP client tool — curl的介紹及用法</title><link href="https://homuchen.com/posts/linux-http-client-tool-curl-usage/" rel="alternate" type="text/html" title="A Linux HTTP client tool — curl的介紹及用法" /><published>2021-03-24T20:00:00+08:00</published><updated>2021-03-24T20:00:00+08:00</updated><id>https://homuchen.com/posts/linux-http-client-tool-curl-usage</id><content type="html" xml:base="https://homuchen.com/posts/linux-http-client-tool-curl-usage/">&lt;p&gt;做為一個HTTP client，想要對server發出請求，有許多做法，可能是寫一個python script 或使用其他任何語言，也可以是使用&lt;a href=&quot;https://www.postman.com/&quot;&gt;postman&lt;/a&gt;這樣的工具，或者是直接在command line上或shell script中使用curl指令．當你想要快速地測試一下某個API，或是explore別人的HTTP service時，直接使用curl是還蠻方便的！甚至直接用shell script來寫爬蟲了！&lt;/p&gt;

&lt;h1 id=&quot;outline&quot;&gt;Outline&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP Request message&lt;/li&gt;
  &lt;li&gt;Curl 的許多參數及用法&lt;/li&gt;
  &lt;li&gt;如何知道自己curl有沒有寫對&lt;/li&gt;
  &lt;li&gt;其他常見搭配的用法及使用情境&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/curl-1.jpg&quot; alt=&quot;curl&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;http-request-message&quot;&gt;HTTP Request message&lt;/h1&gt;

&lt;p&gt;作為一個HTTP client，要送出一個request，我們先必須知道送出去的message到底會有哪些東西組成．&lt;/p&gt;

&lt;h2 id=&quot;request-line&quot;&gt;Request line&lt;/h2&gt;
&lt;p&gt;HTTP message的第一行，由method、URL、version所組成，例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET /index.html HTTP/1.1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;header-lines&quot;&gt;Header lines&lt;/h2&gt;
&lt;p&gt;第二行開始，每一行是為一個header，field及value由冒號隔開，例如&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Host: www.google.com
Connection: Close
Accept-Language: en
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;body&quot;&gt;body&lt;/h2&gt;
&lt;p&gt;Header結束空一行之後是為body，method是GET的就沒有body，例如你的表單POST的一些資料就會放在body，可能長這樣：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;name=HoMu&amp;amp;phone=0912345678&amp;amp;email=homu@email.com
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;更多關於HTTP message的說明，可以看我之前寫過的文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/http-introduction-telnet-nc-curl&quot;&gt;[Networking] HTTP 簡介，以及使用telnet、nc、curl等指令來探索&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;curl&quot;&gt;Curl&lt;/h1&gt;
&lt;p&gt;所以我們要如何使用curl指令來產生HTTP message呢？！&lt;/p&gt;

&lt;h2 id=&quot;基本&quot;&gt;基本&lt;/h2&gt;
&lt;p&gt;URL是必須的，什麼參數都沒有，就產生一個GET message&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl www.google.com
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-x&quot;&gt;-X&lt;/h2&gt;
&lt;p&gt;設定你想要的method，例如你想要POST，如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -X POST api.host.com/v1/users
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-h&quot;&gt;-H&lt;/h2&gt;
&lt;p&gt;加上headers，用冒號隔開field及value，如果想要多個header就多打幾次-H，如：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -X POST \
     -H 'Content-Type: application/json' \
     -H 'X-Whatever-Field: value' \
     api.host.com/v1/users
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-d&quot;&gt;-d&lt;/h2&gt;
&lt;p&gt;加上body，比如你想POST JSON string的data給你的API：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -X POST -H 'Content-Type: application/json' localhost:3000/api -d '{&quot;name&quot;: &quot;HoMu&quot;, &quot;age&quot;: 30}'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你data很多，想在一個檔案裡頭，也可以使用指定檔案路徑的方式，可以為絕對路徑，也可以是相對的，路徑前必須加上@，例如：-d @./data.json&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -X POST -H 'Content-Type: application/json' localhost:3000/api -d @FILEPATH
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-i&quot;&gt;-i&lt;/h2&gt;
&lt;p&gt;按下Enter後，你得到會是server傳回來的body，如果你想要看response的header的話，要加上-i&lt;/p&gt;

&lt;h2 id=&quot;-f&quot;&gt;-F&lt;/h2&gt;
&lt;p&gt;上傳檔案&lt;/p&gt;

&lt;h1 id=&quot;利用nc指令看看自己到了傳了什麼&quot;&gt;利用nc指令看看自己到了傳了什麼&lt;/h1&gt;
&lt;p&gt;你可能寫了curl指令，不太確定用法，想知道到底curl形成出來的message是不是自己想要的格式，這時可以使用nc指令，在本機端起一個tcp server，在curl這個server，就可以看到HTTP的message囉．&lt;/p&gt;

&lt;h2 id=&quot;nc監聽在port-3000&quot;&gt;nc監聽在port 3000&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;nc -l 3000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;curl-port-3000&quot;&gt;curl port 3000&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl localhost:3000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;其他常見使用情況&quot;&gt;其他常見使用情況&lt;/h1&gt;
&lt;h2 id=&quot;redirect&quot;&gt;redirect&lt;/h2&gt;
&lt;p&gt;當curl回來的資料是html時，直接在terminal上噴出一堆字也是很難看，這時長搭配redirect io，把回傳回來的html string寫到檔案裡，就可以用瀏覽器打開來了．&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl www.google.com &amp;gt; gg.html
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;jq&quot;&gt;jq&lt;/h2&gt;
&lt;p&gt;如果content-type是json的話，可以使用jq command幫你parse，不然一堆json string噴在螢幕上，也是眼花．&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl api.host.com/users | jq
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;今天簡單看了一下HTTP message的格式，以及如何用curl來做出自己想要的HTTP Request，並且知道自己到底有沒有寫對．&lt;/p&gt;

&lt;p&gt;感謝大家的收看，如有錯誤歡迎指正，下次見！&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;參考資料&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jq - &lt;a href=&quot;https://stedolan.github.io/jq/&quot;&gt;https://stedolan.github.io/jq/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Networking" /><category term="http" /><category term="linux" /><category term="curl" /><summary type="html">做為一個HTTP client，想要對server發出請求，有許多做法，可能是寫一個python script 或使用其他任何語言，也可以是使用postman這樣的工具，或者是直接在command line上或shell script中使用curl指令．當你想要快速地測試一下某個API，或是explore別人的HTTP service時，直接使用curl是還蠻方便的！甚至直接用shell script來寫爬蟲了！</summary></entry><entry><title type="html">HTTP 簡介，以及使用telnet、nc、curl等指令來探索</title><link href="https://homuchen.com/posts/http-introduction-telnet-nc-curl/" rel="alternate" type="text/html" title="HTTP 簡介，以及使用telnet、nc、curl等指令來探索" /><published>2021-03-24T20:00:00+08:00</published><updated>2021-03-24T20:00:00+08:00</updated><id>https://homuchen.com/posts/http-introduction-telnet-nc-curl</id><content type="html" xml:base="https://homuchen.com/posts/http-introduction-telnet-nc-curl/">&lt;p&gt;在網路的世界裡，HTTP扮演著一個重要角色，當你打開Instagram看著無以計數的照片、打開Youtube看看影片、在google上搜尋著你想要知道的答案、瀏覽著別人的網站文章，這些都是HTTP負責把上述的這些照片、影片、文字、等檔案資源從別處的伺服器搬到你的裝置裡，可能是你的手機、平板或是電腦．&lt;/p&gt;

&lt;p&gt;HTTP在OSI模型中，是屬於應用層(Application layer)裡的一個通訊協定，透過傳輸層(Transport layer)的TCP來傳輸資料．&lt;/p&gt;

&lt;p&gt;關於application layer在整個分層架構中扮演什麼樣的角色，可以參考我之前寫的文章: &lt;a href=&quot;/posts/networking-application-layer-overview-what-is-socket&quot;&gt;[Networking]Application Layer Overview，什麼是Socket?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;client-server-protocol&quot;&gt;Client server protocol&lt;/h1&gt;
&lt;p&gt;HTTP是這樣的，想要發起通訊請求的一方作為client(例如你的瀏覽器)，而server則隨時等候，回應client的請求，client首先會建立一個TCP socket，至於TCP連線是怎麼建立，以及資料如何透過TCP connection在client及server之間傳送，則是另外一回事，並不是HTTP需要考慮的事．&lt;/p&gt;

&lt;p&gt;Client送出一個請求，例如我要看youtube! 而youtube的server收到這個請求，則回應給他youtube的介面，以及一些影片的清單．&lt;/p&gt;

&lt;p&gt;HTTP既然作為client及server之間的語言，他必須有個規範大家才聽得懂，不然有人講中文，有人說英文這樣是無法溝通的．以下就來看看HTTP所傳送的資料到底是長怎樣．&lt;/p&gt;

&lt;h1 id=&quot;http-message&quot;&gt;HTTP message&lt;/h1&gt;
&lt;p&gt;HTTP message分成兩種，請求(request)及回應(response)，他基本上就是人類可以讀懂的文字．&lt;/p&gt;

&lt;h2 id=&quot;request-message&quot;&gt;Request message&lt;/h2&gt;
&lt;p&gt;以下一個範例，當你在網址上輸入www.google.com時，你的瀏覽送出去的HTTP message可能會是這樣:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET / HTTP/1.1
Host: www.google.com
Connection: Close
User-agent: Mozilla/5.0
Accept-language: en
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一行為request line，由三個部分組成，method、URL、version，分別以空格隔開．&lt;/p&gt;

&lt;p&gt;常見的method有GET 、POST 、PUT 、DELETE 、HEAD等等，GET非常地常見，通常代表著你想要取得的某些資源，而你想取的資源則用URL表示，最後HTTP/1.1就是版本．&lt;a href=&quot;/posts/&quot;&gt;點我看更多關於method的介紹．&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第二行開始為header lines，field跟value以冒號(:)隔開，上面例子中有Host、Connection、User-agent、Accept-language四個header，還有許許多多的header各自有各自的意義，Host代表server，Connection: Close是叫server回傳完資料後就把TCP connection close掉，關於persistent connections的部分，之後會再寫一篇文章來詳細探討．&lt;/p&gt;

&lt;h2 id=&quot;request-body&quot;&gt;Request body&lt;/h2&gt;
&lt;p&gt;如果client需要傳送額外的資料給server，就要把資料放在body的部分，是在header lines之後空一行，比如說我要通過一個API新增一個user&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;POST /users HTTP/1.1
HOST: api.domain.com
Content-Type: application/json
Connection: Keep-alive

{&quot;name&quot;: &quot;HoMuChen&quot;, &quot;age&quot;: 30, &quot;gender&quot;: &quot;male&quot;}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;response-message&quot;&gt;Response message&lt;/h2&gt;
&lt;p&gt;以下為一個範例:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;HTTP/1.1 200 OK
Server: nginx/1.14.0 (Ubuntu)
Date: Wed, 17 Mar 2021 14:34:29 GMT
Content-Type: text/html
Content-Length: 614
Last-Modified: Wed, 17 Mar 2021 10:27:32 GMT

&amp;lt;!doctype html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;........
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;status-line&quot;&gt;Status Line&lt;/h2&gt;
&lt;p&gt;第一行為status line，由三個部分組成，version、status code、phrase，分別以空格隔開．
Status code 跟 phrase拜表著回應的結果，常見的有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;200 OK：成功&lt;/li&gt;
  &lt;li&gt;301 Moved Permanently: 資源不在此URL，通常搭配著Location的response header，告訴我們要去哪裡取得資源．&lt;/li&gt;
  &lt;li&gt;400 Bad Request: Request有錯，我server看不懂拉．&lt;/li&gt;
  &lt;li&gt;404 Not Found: 資源不存在．&lt;/li&gt;
  &lt;li&gt;500 Internal Server Error: Server出事了…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;header-lines&quot;&gt;Header Lines&lt;/h2&gt;
&lt;p&gt;第二行開始一樣是header lines，我覺得比較重要的是Content-Type，此header就是說明了放在最後body裡的資料是什麼格式，讓client可以去處理．常見的像是text/html、application/json、image/jpeg、application/pdf等等．&lt;/p&gt;

&lt;h2 id=&quot;body&quot;&gt;Body&lt;/h2&gt;
&lt;p&gt;結束header lines之後，空一行，後面就是response body的部分，放著的就是request想要的資料，上面例子中就是html document，也可能是一張圖片的binary data，或是一個Restful API的json資料．&lt;/p&gt;

&lt;h1 id=&quot;get-your-hands-dirty&quot;&gt;Get your hands dirty&lt;/h1&gt;
&lt;h2 id=&quot;telnet&quot;&gt;telnet&lt;/h2&gt;
&lt;p&gt;最後就來使用一些linux command line tool來驗證上面講的對不對吧！&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;telnet www.google.com 80
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用telnet指令，如此一來就跟google建立了一個TCP連線，接下來輸入並且按下Enter&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;GET / HTTP/1.1
Host: www.google.com
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/http-intro-1.jpg&quot; alt=&quot;telnet request response&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就可以看到google把網頁吐回來拉～～&lt;/p&gt;

&lt;h2 id=&quot;nccurl&quot;&gt;nc、curl&lt;/h2&gt;

&lt;p&gt;除了telnet之後，也可以用nc作為建立tcp連線的指令，這裡我們用nc來建立一個server，-l 監聽在本機的port 3000上&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;nc -l 3000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之後在另一個shell，利用curl作為HTTP client，發送HTTP到port 3000&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl localhost:3000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/http-intro-2.jpg&quot; alt=&quot;curl response&quot; /&gt;&lt;/p&gt;

&lt;p&gt;nc的terminal上就會出現這些資訊拉～～也就是curl傳送過來的資料，再來試試看上面開創一個新的user的API call吧&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;curl -XPOST \
     -H 'Content-Type: application' \
     -H 'Connection: Keep-alive' \
     api.domain.com/users \
     -d '{&quot;name&quot;: &quot;HoMuChen&quot;, &quot;age&quot;: 30, &quot;gender&quot;: &quot;male&quot;}'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nc server就會收到下面的資料拉！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/http-intro-3.jpg&quot; alt=&quot;curl request&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;HTTP作為網路中最常用的client server 通訊協定，簡單地介紹了HTTP message的格式，他是human readable的text format，熟悉他到底傳來傳去到底在傳什麼，可以幫助我們開發網頁應用時更有底氣．&lt;/p&gt;

&lt;p&gt;也可以學習使用一些linux指令，快速的explore別人的API，或是看看自己送出去的request到底有沒有對．&lt;/p&gt;

&lt;p&gt;感謝您的閱讀~期待下次見！&lt;/p&gt;</content><author><name></name></author><category term="Networking" /><category term="http" /><category term="linux" /><category term="curl" /><category term="nc" /><category term="telnet" /><summary type="html">在網路的世界裡，HTTP扮演著一個重要角色，當你打開Instagram看著無以計數的照片、打開Youtube看看影片、在google上搜尋著你想要知道的答案、瀏覽著別人的網站文章，這些都是HTTP負責把上述的這些照片、影片、文字、等檔案資源從別處的伺服器搬到你的裝置裡，可能是你的手機、平板或是電腦．</summary></entry><entry><title type="html">[System Design]Data model: Relational V.S. Document</title><link href="https://homuchen.com/posts/system-design-data-model-relational-vs-document/" rel="alternate" type="text/html" title="[System Design]Data model: Relational V.S. Document" /><published>2020-12-28T20:00:00+08:00</published><updated>2020-12-28T20:00:00+08:00</updated><id>https://homuchen.com/posts/system-design-data-model-relational-vs-document</id><content type="html" xml:base="https://homuchen.com/posts/system-design-data-model-relational-vs-document/">&lt;p&gt;開發應用程式時，時常使用到資料庫，儲存資料並在之後需要時將其取出，如今有許多的資料庫產品可供選擇，提供各種不同的data model及function，在各種使用情境下有不同的表現，開發者根據你的應用程式的需求、資料之間的關係、access pattern、scalability、ACID transaction、fault-tolerance、會有各種不同的適合的選擇．&lt;/p&gt;

&lt;p&gt;接下來只單純討論資料庫提供給我們application programmer們的data model，看看是否在哪些情況比較適合用哪一種，主要是探討relational 及 document這兩種data model.&lt;/p&gt;

&lt;h1 id=&quot;one-to-many-relationship&quot;&gt;One-to-many relationship&lt;/h1&gt;
&lt;p&gt;讓我們先從一個簡單的例子Todo list開始，假設我們應用程式有使用者，每個使用者有多個Todo，就這麼簡單的一個one-to-many relationship．&lt;/p&gt;

&lt;h2 id=&quot;relational-dbms&quot;&gt;Relational DBMS&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/data-model-1.jpg&quot; alt=&quot;database relationship&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上圖， 一般使用SQL database的做法，會開兩個table，分別是users及todos，並且在todos table有個欄位user_id為foreign key指到user table&lt;/p&gt;

&lt;h2 id=&quot;document-database&quot;&gt;Document database&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/data-model-2.jpg&quot; alt=&quot;document in NoSQL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而在document database中，我們可以將整個資訊存成一個JSON document如上圖，當我們的UI需要呈現某使用者的todo的時候，資料庫只需要一個disk seek就可以拿到全部的資料，對比於relational database，必須在todos table裡找到相對應的rows，再將其與users的row合併．&lt;/p&gt;

&lt;p&gt;可以看到document database用來model one-to-many relationship的資料可說是天生的適合．&lt;/p&gt;

&lt;h1 id=&quot;many-to-one-and-many-to-many-relationship&quot;&gt;Many-to-one and Many-to-many relationship&lt;/h1&gt;

&lt;p&gt;現在假設我們要加入新的功能，使用者可以新增標籤，並把自己的Todo加上一個標籤．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/data-model-3.jpg&quot; alt=&quot;Many-to-many relationship&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Relational database按照normalization的做法，就是再多一個tags table，user_id指向Users，而Todos再多一個foreign key指向Tags，如上圖沒什麼問題．&lt;/p&gt;

&lt;p&gt;而Document database則會向下圖這樣:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/data-model-4.jpg&quot; alt=&quot;document in NoSQL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;資訊重複出現了好幾個地方，容易造成不一致，比如說我想把Coding改成Programming，除了在tags這個array裡面要修改之外，兩個todo裡的tag也要同時修改才行．&lt;/p&gt;

&lt;h2 id=&quot;document-database就不能做normalization嗎&quot;&gt;Document database就不能做normalization嗎？&lt;/h2&gt;
&lt;p&gt;當然是可以的！分別儲存三種類型的document: User、Tag、Todo，當某個user要取得他的資料時，就必須分別從三類document找出相對的document，在合併起來．&lt;/p&gt;

&lt;p&gt;那這跟relational database的join有什麼不一樣嗎？&lt;/p&gt;

&lt;p&gt;其實本質上是一樣的！只不過使用relational database時是database幫你做，而使用document database則是要在application code上面自己做，除了會有更多的network round trip time之外，relational database通常也會幫你優化．&lt;/p&gt;

&lt;h1 id=&quot;schema-flexibility&quot;&gt;Schema flexibility&lt;/h1&gt;
&lt;p&gt;另外他們倆之間常被討論到的不同，就是schema的有無，雖然說document database可以讓你隨意的放入任何的JSON document，但我們通常不會這樣做，一般來說都會把相同類型，有ㄧ樣資料格式的document放在一起，只不過資料庫本身並不會強迫每個document的schema要一模一樣．&lt;/p&gt;

&lt;p&gt;這樣的彈性，讓schema evolution也算方便，資料庫裡可以同時保有舊有的資料和新的資料 ，比如說todo想要新增一個欄位created_at，或是todo原本只能有一個tag，用一個string來表示，現在想要改成可以有多個tag，新新增的資料不在是一個string而是一個array．&lt;/p&gt;

&lt;p&gt;但如此一來application programmer在使用document database時，就不能保證拿到的資料的格式，會出現類似這樣的code:&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;todo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;todo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;created_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;todo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;todo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;時間久了，資料可能會越來越亂，一不注意就跑出個error:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cannot read property ‘some_field’ of undefined!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;該如何管理schema evolution，不讓你的應用程式crash，隨著新功能及新資料的加入能夠compatible，繼續穩定的運行就是另一門學問，有機會可以再來探討．&lt;/p&gt;

&lt;h1 id=&quot;whats-the-situation-preferring-to-schema-less-approach&quot;&gt;What’s the situation preferring to schema-less approach?&lt;/h1&gt;
&lt;p&gt;其實能有schema最好就有，他是你的資料的一個documentation，一個contract，讓programmer寫起程式來更有信心，不用擔心東擔心西，擔心會不會少了個欄位就讓我的process crash掉，那有什麼樣的情況會更適合使用document database嗎？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;資料來自外部，格式不是妳能控制的&lt;/li&gt;
  &lt;li&gt;有非常多種類的object，分別將每個object放到個別的table可能不太適合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如說event sourcing的架構，每種event type都有各自的資料格式，放在relation database的一個table，會有很多欄位是空的，schema定義起來也會非常麻煩．&lt;/p&gt;

&lt;p&gt;再來你的資料來源可能來自爬蟲、外部的API，格式可能改變，所以可以在拿到資料的時候就先存起來，之後讀的時候做處理，不然可能就會丟失部分的資料了．&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;如果你的資料之間的關係不複雜，基本上是one-to-many的，一個self-contained的JSON document能夠包含所有需要的資料，那麼document based的DBMS就相當適合，會有更好的performance，因為資料都在一起．&lt;/p&gt;

&lt;p&gt;Relational database更適合當你的資料之間的關係複雜，有許多many-to-one、many-to-many relationship時，幫你處理join的動作，雖說使用document database也是可以如此，但join的動作必須在application code上執行．&lt;/p&gt;

&lt;p&gt;另外document database也提供更彈性的schema，當你的應用需要面對許多不同且不確定、不是自己能控制的資料格式時，document database也許會有更好的support．&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321&quot;&gt;Designing Data-Intensive Applications Chapter 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://martinfowler.com/articles/schemaless/&quot;&gt;https://martinfowler.com/articles/schemaless/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>HoMuChen</name></author><category term="Web Development" /><category term="data model" /><category term="system design" /><category term="database" /><summary type="html">開發應用程式時，時常使用到資料庫，儲存資料並在之後需要時將其取出，如今有許多的資料庫產品可供選擇，提供各種不同的data model及function，在各種使用情境下有不同的表現，開發者根據你的應用程式的需求、資料之間的關係、access pattern、scalability、ACID transaction、fault-tolerance、會有各種不同的適合的選擇．</summary></entry><entry><title type="html">如何用create-react-app開發，整合一個或多個API backend server</title><link href="https://homuchen.com/posts/create-react-app-integrate-multiple-api-backend-servers/" rel="alternate" type="text/html" title="如何用create-react-app開發，整合一個或多個API backend server" /><published>2020-08-22T20:00:00+08:00</published><updated>2020-08-22T20:00:00+08:00</updated><id>https://homuchen.com/posts/create-react-app-integrate-multiple-api-backend-servers</id><content type="html" xml:base="https://homuchen.com/posts/create-react-app-integrate-multiple-api-backend-servers/">&lt;p&gt;在開發single page application時，會需要透過api來取得及操作資料，本篇文章將示範如何在使用create-react-app開發時，整合一個甚至是多個backend api server！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/cra-1.jpg&quot; alt=&quot;create-react-app with multiple backend servers&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;create-react-app&quot;&gt;Create-react-app&lt;/h1&gt;
&lt;p&gt;使用create-react-app時，簡單一個指令npm start 就可以開始開發，此時CRA會起一個webpack dev server來serve static files，通常我們會想要做類似這樣的動作: fetch(‘/todos’) 、fetch(‘/api/todos’) 來跟我們的API server通訊，此時該如何讓CRA的dev server將request proxy到我們想要的API server呢？&lt;/p&gt;

&lt;h1 id=&quot;透過packagejson&quot;&gt;透過package.json&lt;/h1&gt;
&lt;p&gt;最簡單的方法就是在package.json中加一個proxy欄位，”proxy”: “http://localhost:5000” ，如此一來，所有的request便會被proxy到http://localhost:5000．&lt;/p&gt;

&lt;h2 id=&quot;想解決的問題&quot;&gt;想解決的問題&lt;/h2&gt;
&lt;p&gt;這樣的做法很簡單但卻不太彈性，通常我們會希望外部的資源可以透過環境變數去控制，而不是寫死在檔案裡面，同一份codebase，透過設置不同的環境變數擁有不同的部署，可能是開發環境、測試環境、或staging、production環境 (https://12factor.net/codebase) ．&lt;/p&gt;

&lt;p&gt;另外將proxy寫在package.json中，只能將所有的ajax導到同一個server，假如您是service oriented architecture或microservices這種架構，可能會有許多的服務，例如data api、search api、authentication api、payment api等等．那該如何將不同的path，例如/api、/search、/auth，route到各自的服務呢？&lt;/p&gt;

&lt;h1 id=&quot;透過setupproxyjs&quot;&gt;透過setupProxy.js&lt;/h1&gt;
&lt;p&gt;首先需要安裝dependency&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;npm i -D http-proxy-middleware
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著在src資料夾裡新增一個檔案setupProxy.js，範例如下:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;createProxyMiddleware&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;http-proxy-middleware&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;API_HOST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;API_HOST&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SEARCH_HOST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;SEARCH_HOST&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AUTH_HOST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;AUTH_HOST&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/api&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;createProxyMiddleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;API_HOST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  
  &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/search&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;createProxyMiddleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SEARCH_HOST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  
  &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;/auth&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;createProxyMiddleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AUTH_HOST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;changeOrigin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如此一來，就能透過環境變數API_HOST、SEARCH_HOST、AUTH_HOST來指向你的服務，變且成功整合多個服務囉！&lt;/p&gt;</content><author><name>HoMuChen</name></author><category term="Web Development" /><category term="react" /><category term="create-react-app" /><summary type="html">在開發single page application時，會需要透過api來取得及操作資料，本篇文章將示範如何在使用create-react-app開發時，整合一個甚至是多個backend api server！</summary></entry><entry><title type="html">[Networking]Application Layer Overview，什麼是Socket?</title><link href="https://homuchen.com/posts/networking-application-layer-overview-what-is-socket/" rel="alternate" type="text/html" title="[Networking]Application Layer Overview，什麼是Socket?" /><published>2020-05-05T20:00:00+08:00</published><updated>2020-05-05T20:00:00+08:00</updated><id>https://homuchen.com/posts/networking-application-layer-overview-what-is-socket</id><content type="html" xml:base="https://homuchen.com/posts/networking-application-layer-overview-what-is-socket/">&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/app-layer-1.jpg&quot; alt=&quot;application layer&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;process-communication&quot;&gt;Process communication&lt;/h1&gt;
&lt;p&gt;上次講過了網路的分層架構之後，接下來要來關注application layer，這一層就是我們應用程式所在的地方，應用程式可能是網頁瀏覽器、電子信箱、Skype等等，每種不同的應用程式會有他們自己的通訊協定，規定應用程式之間該如何交換資料，以及資料的格式，常見的協定例如是HTTP、FTP、DNS等等．&lt;/p&gt;

&lt;p&gt;那application layer的process們之間要怎麼互相通訊呢？就是要利用transport layer所提供的服務．&lt;/p&gt;

&lt;h1 id=&quot;what-is-socket&quot;&gt;What is socket?&lt;/h1&gt;
&lt;p&gt;Application layer的process必須使用transport layer所提供的服務來進行通訊，而這之間的介面就是socket，process只要把資料寫入socket，另一個process從socket讀出資料就好，就是這麼簡單～至於資料是如何在這之間傳遞的，底下的每一層 (transport、network、link、physical layer) 都幫你處理的好好的了，applications就只需要專心做自己的事就好！&lt;/p&gt;

&lt;p&gt;不過在通信之前，必須要知道對方在哪裡，資料才有辦法送到，一個socket就是一組ip:port pair，ip用來分別process所在的機器，而一台機器上會有許多的process，port number則用來分別是想要跟哪個程序溝通，有些服務基本上監聽在一些固定的port上，方便client來連，例如HTTP使用80、FTP用21、SSH使用22等等．&lt;/p&gt;

&lt;p&gt;另外當client要向server通訊時，作業系統會隨機指定一個port給他，如此一來server才會知道訊息要回傳到哪裡．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.googleapis.com/homuchen.com/images/app-layer-2.jpg&quot; alt=&quot;application layer&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;transport-layer-service&quot;&gt;Transport layer service&lt;/h1&gt;
&lt;p&gt;Application programer可以根據自己想打造的應用程式的需求，在兩種transport layer所提供的服務中選擇，一個是TCP，另一個是UDP，以下分別介紹．&lt;/p&gt;

&lt;h2 id=&quot;tcp&quot;&gt;TCP&lt;/h2&gt;
&lt;p&gt;TCP提供的是一個可靠的服務，確保資料一定會完整無缺的抵達另一端，使用TCP的application programmer不用擔心資料會到不了另一端，專心於application protocal就好．&lt;/p&gt;

&lt;p&gt;TCP有congestion control的機制，當網路變得壅塞的時候，會放慢sender的速度，這是為整個網路著想的設計，但對於application並沒有直接的幫助，可能還會使得速度變慢．&lt;/p&gt;

&lt;h2 id=&quot;udp&quot;&gt;UDP&lt;/h2&gt;
&lt;p&gt;UDP的服務並不可靠，也就是並不保證資料一定會送達，對於一些應用來說或許是可以接受的，比如即時的通話或視訊，上一秒的聲音或畫面不見就不見了．是ok的．&lt;/p&gt;

&lt;p&gt;另外UDP也沒有flow control跟congestion control，sender想送多快就多快，所以如果有application覺得TCP做太多事了，開發起來綁手綁腳，想要看短的latency，就可以考慮使用TCP，例如google的QUIC就是基於UDP上，再重新自己實現了可靠的傳輸．&lt;/p&gt;

&lt;h1 id=&quot;socket-programming&quot;&gt;Socket programming&lt;/h1&gt;
&lt;p&gt;之後會寫一篇使用Node.js的net module來實際地使用一下TCP的服務，並在這之上打造自己的application protocol，待續…&lt;/p&gt;

&lt;h1 id=&quot;application-layer-protocols&quot;&gt;Application layer protocols&lt;/h1&gt;
&lt;p&gt;接著也會陸續會介紹一些常用的application layer的protocol: HTTP、SMTP、DNS，待續…&lt;/p&gt;</content><author><name></name></author><category term="Networking" /><category term="linux" /><category term="socket" /><category term="tcp" /><category term="udp" /><summary type="html"></summary></entry></feed>