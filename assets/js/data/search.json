[ { "title": "RabbitMQ和Kafka有何不同？何時該選用哪種產品？", "url": "/posts/difference-bwtween-rabbitmq-and-kafka/", "categories": "Web Development", "tags": "message queue, kafka", "date": "2021-10-16 23:00:00 +0800", "snippet": "在上篇文章中，看完了為何要使用message queue之後，今天要討論兩類message broker的差異，分別是memory based及log based，memory based像是使用Redis作為broker或RabbitMQ，而log based最有名的，就比如說是Kafka。這篇文章會先來看看message broker普遍的基本特性及用法，然後再討論兩種broker的內部設計的不同，最後就可以比較在各種特性上，兩者的不同。基本特性Message borker最基本的操作就是produce跟consume，一個產生message，一個消耗message，此時我們可以問的幾個問題如下:Multiple consumers 當有多個consumer時，每個message會被處理多次嗎？還是只會被其中一個consumer處理到一次？Load balancing每個message只會被其中一個consumer處理到，所以你可以指派任意多個consumer去consume一個topic，當你想要並行處理你的工作時，這會非常有用。Fan-out每個message會被送到所有的consumer去處理，像是broadcast，可以用在當你的message需要到各個不同的系統時，比如說一筆交易的資料，需要被送到data warehouse保存、送到BI分析給老闆看、送到使用者的系統來更新他的交易資訊頁面。Persistence 當broker掛掉時，已經發送過來的messsage會消失嗎？還是等到broker重啟之後，會再重新發送？就是顧名思義，producer的每個message，是否會確保送到consumer那邊，broker掛掉，message還會不會在。不過consumer有沒有處理好這個message又是另一回事了(見下段Acknowledgements)。Acknowledgements 當consumer工作到一半掛掉時，如何確保每個message已經被完整地處理好了呢？因為consumer也可能隨時會掛掉，可能在收到訊息之前，或收到訊息但工作到一半時，broker為了確保訊息有好好地到達，會使用acknowledgement，acknowledgement就是必須由consumer告訴broker，他已經收到message，broker可以將他從queue中移除了，至於ack的時機不同會導致訊息被處理的次數的保證的不同。At most once先ack，再處理訊息，如果在處理到一半時掛掉，這個訊息就沒被完整處理到了，因為已經ack了，broker已經把訊息從queue中移開，不會再發送這個訊息出來，所以最差的情況就是沒被處理到，正常的情況就是處理一次，而且最多一次，此為at most once。//consumer first ack the message and the processfunction (message) { queue.ack(message) essage.ack()}At least once想反地，先處理訊息再ack，如果在處理到一半時掛掉，因為還沒ack，broker會再發送這個訊息出來，所以最差的情況就是訊息被處理到多次，正常的情況就是處理一次，而且至少一次，此為at least once。//consumer processes the message first and then ack itfunction (message) { process(message) message.ack()}Internal Design現在就來看看message system的內部設計，如此一來就可以知道各個系統的特性以及該如何回答上面的問題，Memory based這類系統顧名思義，主要使用memory作為message存放的地方，當consumer ack了某個信息後，就把它刪掉了，完全不留痕跡。當然很多系統也可以透過設置，決定要不要將信息寫到硬碟上，不過主要是用來做recovery的，確保broker本身掛掉時，message不會丟失，當確認了message已經成功抵達了它要到的地方後，一樣會把它刪掉。此類系統著重的是message從producer到consumer的過程，而不是留下一個永久的狀態或結果。而信息的傳送是由broker主動push給consumer的。Log based而log based的系統則是相反，只有要message進來，就都寫到硬碟上，是一個append only log，當consumer要消耗信息時，就是讀取檔案上的資料，讀到盡頭了就等通知，等有新的資料繼續被append到檔案中，有點像是Unix tool tail -f 的感覺。此時，信息的傳送consumer去向brokerpull。為了不讓寫入的速度被限制一個硬碟上，需要將一個topic的log partitioned，每個partition由一台機器負責，可以獨立地讀寫。Comparison between RabbitMQ and Kafka終於可以來看看兩者的比較拉～ 首先奉上一個表格，再來一點一點詳細討論！ 特性 RabbitMQ Kafka Load Balancing Yes Yes, but limited Fan-out Yes, through exchabge binding Yes Persistence Yes, through configuration Yes Inorder delivery Yes, conditionally yes, per partition Load Balancing Memory based: 自然地support了load balancing，當有message時，broker輪流地向跟他有建立連結的consumer推送信息，就達成了load balancing的效果，越多consumer，就可以平行處理越多的工作。 Log based: 無法天生支援load balancing，因為每個consumer彼此是各自獨立的，分別從頭、或從某個地方開始讀取log檔案，所以想達成load balancing，是透過partition的方法: 假設我現在有一個topic，並且將它partition成三份，此時就可以assign三個consumer給他，看起來就像是這一個topic的message被分給三個consumer，而實際上是每一個partition對應到一個consumer，所以！可以同時平行處理這個topic的consumer的數量，也就會是partition的數量。 Fan-out Memory based: 需要透過額外的設計才能達成，RabbitMQ implememt的AMQP協議，exchange binding可以實現pub-sub的patter。 Log based: 自然地support fan-out，每個consumer對log檔案想讀哪就讀哪，想重複讀幾次就讀幾次。Persistence Memory based: 透過設置，可以同步將message寫入硬碟，確保不會丟失，不過就只保存到當consumer成功消耗之前。 Log based: 如前面所述，每個message都會寫入硬碟，除非你說要刪掉它，不然就會一直在。Inorder delivery Memory based: 無法保證message一個一個按照順序的被處理，除非每一個topic只有一個consumer。 Log based: 每個partition上的message，一定是被consumer做一個sequential read的動作，所以信息一定會被按照順序讀取，但不同partition之間就沒有順序的保證，他們基本上是獨立的。Use cases最後就來看看在哪些場景比較適合使用哪一種產品吧！是否需要被保存下來?如果你想要message被保存下來，那就用log based的messaging system，保存下來有哪些好處呢？ 可以肆無忌憚地去consume message，可以去嘗試、做實驗，不用怕message會不見， 各種event sourcing的好處，有興趣的可以google它看看～工作昂不昂貴?如果處理一個message的工作量是很大的，需要耗費很多時間才能做完，你可以比較不會想用log based的產品，為什麼呢? 它無法使用大量的consumer來平行地處理所有的工作，因為可以平行工作的consumer的數量受限於partition的數量 在一個partition裡，只要有個message需要耗費很多的時間，就會造成塞車，也就是head of line blocking。順序重要嗎?有些類型的message彼此是獨立不相干的，被處理順序是如何並不重要，就沒一定要使用log based的產品，但當你需要保留message的順序時，唯有log based的messaging system可以給你保證，不過只限定於同個partition。有哪些例子是順序重要的呢? 比如說對一個使用者的帳戶餘額做加減乘除的運算，順序不同結果就不同，但你可以使用user id作為partition key，則在每一個partition裡保持對的順序就好，不同的partition間的順序就不重要了。感謝你閱讀到這邊～ 希望以上的內容對你有一丁點的幫助，掰掰～ 👋" }, { "title": "RESTful API: How to design paths and identify resources", "url": "/posts/restful-api-how-to-design-paths-and-identify-resources/", "categories": "Web Development", "tags": "http, restful api, api", "date": "2021-10-14 13:20:00 +0800", "snippet": "繼上篇文章RESTful API簡介: 什麼是RESTful? 以及為何需要它?後，我們知道了RESTful API是resource based的，今天講著重討論該如何設計resource，也就是HTTP URL中path的部分。Resource based每個URL都應該對應到一個或多個資源，使用那些使用者與你的服務互動時會需要用到的資源(名詞)，並使用HTTP Method來表明你想要對資源的操作(動詞)，比如說你是一個網誌服務，使用者可以看、新增、修改、刪除自己的文章，也能瀏覽別的作者的文章，GET /articles -&amp;gt; 看全部的文章GET /articles/d8e209 -&amp;gt; 看某篇文章POST /articles -&amp;gt; 新增文章PUT /articles/4f8662 -&amp;gt; 修改某篇文章DELETE /articles/4f8662 -&amp;gt; 刪除某篇文章GET /authors/homuchen -&amp;gt; 看作者homuchen的資訊GET /authors/homuchen/articles -&amp;gt; 看作者homuchen的所有文章將操作轉成名詞如果你想要進行的操作比較複雜，可能是需要同時對多個資源進行操作，又或者是無法以CRUD之一來表示，可以考慮自己創造一個新的Resource。無法以CRUD表示比如說你想要lock及unlock某篇文章，此時只有一個人可以讀取或修改它，HTTP Method裡沒有可以表示lock及unlock的操作，所以就自己創造一個資源叫article-locks，並使用PUT、DELETE來操作。PUT /article-locks/{article_id} -&amp;gt; Lock住某篇文章DELETE /article-locks/{article_id} -&amp;gt; Unlock某篇文章牽涉多個資源當你的一個任務需要同時對多個資源進行操作時，有兩種做法，一個是讓client發出多個api請求，另一個則是定義一個新的endpoint，來幫使用者做完所有的事。比如說API的使用者想要發起一筆交易，需要從A帳戶扣一筆錢，在B帳戶新增一筆錢，如果讓client自己送出兩個api請求也可以，但是他就要處理其他許多狀況，比如說其中一個api成功，另一個失敗怎麼辦。#還要確保兩個api request同時成功或同時失敗PUT /accouts/A/withdrawal -&amp;gt; 從A帳戶扣一筆錢PUT /accouts/B/deposit -&amp;gt; 在B帳戶新增一筆錢或者可以創造一個新的資源叫transaction，使用PUT來發起一筆交易，而api server則幫client處理了所有該注意的事，使這個交易atomic、檢查A帳戶裡的餘額夠不夠等等…PUT /transactions -&amp;gt; 發起一筆交易Identify sub-resources via path segments有些資源他本身可能沒有意義，也不會被直接使用，必須仰賴在某些資源下，才知道他所要代表的事物，比如說文章底下的留言，如果不知道它們是在哪篇文章底下，留言本身就無法被看懂，此時可以使用多段的path來表示parent-child的階層關係。/articles -&amp;gt; 所有文章/articles/{article-id} -&amp;gt; 某篇文章/articles/{article-id}/comments -&amp;gt; 某篇文章的所有評論/articles/{article-id}/comments/{comment-id} -&amp;gt; 每篇文章的某則評論Summary今天看了要如何設計我們API的URL，重點就是URL是資源、是名詞，搭配method，表示要對資源進行的操作，當操作無法以CRUD表示、或需要同時對多個資源進行操作時，可以考慮創造新的domain entity。另外當資料有階層性的關係時，可以使用多段的path還表示。這是RESTful API一系列文章中的一篇，想了解更多關於RESTful API及HTTP的，可以看這篇目錄:RESTful API Design — A practical guide" }, { "title": "[讀書筆記] 一週工作4小時: 擺脫朝九晚五的窮忙生活，晉身「新富族」！", "url": "/posts/book-note-the-four-hour-work-week/", "categories": "讀書筆記", "tags": "books, life style, work", "date": "2021-10-10 23:00:00 +0800", "snippet": "讀完這本《一週工作四小時》後，讓我產生了許多在工作上及生活上的新想法，跳脫朝九晚五的社會框架、認識了新富族、發掘了更多生活型態的可能性。在這篇文章裡，我將會分享我原先既有的一些想法、這本書所提出的內容，最後是我之後可能會做的一些改變！ 每當發現自己屬於多數陣營時，就是你停下來三思的時候 - 馬克.吐溫過去的想法FIREFIRE(Financial Independence Retire Early)[1]，財務自由、提早退休，是我工作之後的幾年一直抱持著的想法，提早規劃退休，儘早儲蓄、投資，打造自己的被動收入，等到被動收入可以支付你的生活支出的時候，蹦！自由了～可以不必為了討生活而工作，擁有自由去做任何你想要做的事，這些都沒錯，也很棒，那問題在哪裡呢？提早退休想要每天醒來不用面對老闆工作上要求嗎？等退休; 想要冬天住在滑雪小屋，每天滑雪，夏天住在海島別墅，每天躺在海灘做日光浴衝浪嗎？等退休; 想要找份對社會有貢獻、有意義的工作嗎？等退休; 想要重拾荒廢已久或培養新的興趣嗎？等退休;為了提早退休，於是在現在做了許多犧牲，我不能休太長的假，因為要賺錢，也怕被炒魷魚，我不能花大錢享受奢華的體驗，因為要存起來，時間久了以後，就有夠多的被動收入可以資助我們想做的事。當我們每天的生活的目標都是為了提早退休，就會變得只追逐金錢，而且有了藉口不去思考更重要的問題: 我想要成為怎樣的人? 我想要做什麼? 因為這些問題都可以用一些簡單的理由來搪塞過去，也就是等退休再說、等有時間再說、等錢夠多了再說…想要的生活終於!熬了十幾年、二十幾年，退休的這天到來了(40幾歲退休還不賴吧？)，突然間擁有了許多的時間，你卻不知道要做什麼，或者是終於去做了你想做很久的事，結果卻發現沒有你想像中的那麼美好。除去了所有不喜歡的事之後，迎來的不會是一個美好人生，而會是一片空白，因為你不知道你想要追求的目標是什麼，有什麼夢想或是事物想要去體驗，過去的人生都在賺錢拼退休…本書摘要本書介紹了一群次文化人士: 新富族，以自由及機動性作為新貨幣，自己決定何時工作、何時追逐夢想、在哪裡生活的一群人。作者提出四個步驟DEAL(Definition、Elimination、Automation、Liberation)，引導大家重新設計生活型態，並且自己親身實踐，可以在書中看到許多作者的經驗及故事。D - 定義人生什麼是新富族(New Rich)，首先先來看看新富族跟延後人生族(工作 -&amp;gt; 儲蓄 -&amp;gt; 退休)的差別在哪吧!所以，誰是新富族？ 重新安排個人行事曆的員工，他談出一份遠距的工作契約，用十分之一的時間達成百分之九十的產出，因而得以自由地去各地滑雪，每月還能有兩週帶家人出門旅遊。 刪去獲利最少的客戶與計畫的老闆，他將所有業務外包，在世界各地旅遊，蒐集罕見的歷史文件，同時在網站上遠距工作，展示他的繪圖設計。 選擇孤注一擲，拿出全部身家的學生，建立網路影片租借服務，從一小群HDTV愛好著的利基市場，每月賺得五千美元的收入。這項每週兩小時的兼差，讓他能夠全職為動物全力奔走。可以看出新富族他們都有以下的共同點:有目標、夢想知道自己想成為怎樣的人，想要做的事，而不是每天埋首於追求金錢、事業、名聲、家庭、生活的的各種瑣事、而忽略了重要的問題，每天致力於除去不想做的事，渴望自由，卻不知道有了時間之後要幹嘛。如果不知道自己想做什麼怎麼辦呢？那更不能繼續埋首工作，要開始思考，並且行動跟實驗，這邊我推薦另一本書《做自己的生命設計師: 史丹佛最夯的生涯規劃課》，瘋狂地發想所有可能的選項，並打造原型去實驗，不知道自己喜歡做什麼時，唯有去做做看才會知道是否喜歡。有錢又有閒你可能會說我哪有那個錢和時間去做這些事！沒錯，目標就是要變得有錢又有閒，後面的EAL就是方法論，教你如何擁有更多的自由時間，以及金錢來資助你過上夢想中的生活。 E(Elimination)，教你去除掉所以不必要花費的時間，維持大部分的產出但同時多出許多時間。 A(Automation)，打造自動創造收入的資產，重點目標是不要花費你的時間，自動的進帳。 L(Liberation)，逍遙自由的機動性，能讓你的財富自動倍增！E - 排除旁騖八十/二十法則八十/二十法則，80%果來自20%的因，在許多地方都能用上這個法則，比如說全世界的資產分配、公司的大部分的利潤來自與少部分的客戶或產品、個人工作的時間與產出，本書作者很喜歡這個法則，並在他其他的書裡也反覆提到，重點就是要找到那最重要的20%的事情，去掉80%的時間與精力，達到足夠滿足的結果。不必要、不重要的工作作者在書中的例子是，他削減了95幾%的客戶及難搞的客戶，不做他們生意，把精力留給帶來大部分利潤的客戶，那些即使你不用聯絡也會持續買單的客戶，結果就是，工作的時間可能只剩下原先的10%，快樂程度高上許多，利潤卻只少掉一點。接著再研究在研究五大客戶的特徵，在下週延攬到三個相似的買家，四周下來，作者營收翻倍，每週工時從80小時降到15小時！不必要的資訊大家每天花在閱讀新聞、滑臉書、PTT的時間有多少呢？這些資訊真的都有必要去知道嗎？現代人吃進太多不具營養價值的空卡路里，資訊也是一樣，多數資訊不僅耗時，而且跟你的目標無關。作者建議，每次要閱讀資訊時，問自己，對我而言，這項資訊有立即、重要的用途嗎? 單單是有關還不夠，還必須是立即且重要的，如果資訊無法用在要事上，或是等你要用的時候也已經忘記了，那就等於無用的資訊。帕金森定律我們有多少的時間完成一項任務，我們就會花多少的時間完成，這就是帕金森定律。每天朝九晚五工作的社會文化，讓我們必須每天在辦公室待上八個小時，就算工作不需要那麼久的時間來完成，我們還是會被迫創造各種活動來填滿時間，如果我們有15小時，就會填滿15小時; 如果我們有8小時，就會填滿8小時; 如果你急事，2個小時後要離開辦公室，那你就會神奇地在2個小時內完成工作。世界上的每個人真的都需要八個小時來完成工作嗎？！這只是重量不重質的社會遺毒，應該要關注產出，而不是在辦公室坐滿八小時，所以員工的下一步就是談出一份遠距工作的契約，好脫離辦公室的框架，變得更有效率，這部分會在後面L的章節更多地討論。A - 自動進帳要想過上奢華生活，或是放手追逐夢想的一個重要要素就是: 收入，在這一階段，就是要打造出可以自動帶來收入的事業，從尋找Idea、找出利基市場、測試廣告效益，最後則是脫身及自動化。因為這部分的內容我自己也沒有實踐，細節就不多在這裡分享了，有興趣的讀者推薦你去書裡看看～簡單分享一個點就是，你可能會覺得所有事情都自己來做比較省錢，自己當客服回覆客戶問題，自己處理訂單、出貨，但以工程師的話來說，這樣就有兩個問題，一個是單點失敗，另一個是無法擴展。 單點失敗: 一但你不能工作了，整個事業就將無法運作，所以你只能一直一直不停地工作 無法擴展: 當客戶越來越多時，總有一天你將會無法自行處理所有的業務L - 逍遙自在如果你每天只在辦公室工作1小時，我想大部分的老闆都會不高興，為了能夠自由地掌握自己的時間、去到任何你想去的地方，想辦法談出一份遠距工作契約將會是第一步。比如當你有辦法做到達到相同產出，但只花1/4的時間時，如果你還待在辦公室，人們就會要求你繼續工作到八小時，以達成4倍的產出，或者你就必須裝忙，來填滿這八小時，這就是社會框架下的辦公室文化。所以作者在這一章節中，教你如何一步一步地得到一份遠距的工作，跟著書中人物的故事，策略性地、有方法地達成遠距工作的目標。Summary看完之後，非常興奮！立馬先查了一下東南亞各地的生活成本，結果發現去峇里島住一個月，大部分根本比住在台北便宜，在曼谷住上五星級的飯店，擁有頂樓無邊際泳池及健身房，跟在台北租個鳥籠的價格也相去不遠，那我幹嘛要住在台北呢XD以上只是利用機動性達成最簡單的地理套利，想要體驗奢華的生活，沒有一定要成為億萬富翁，賺錢不是目的，過上你想要過的生活才是。重要的是我們要如何利多出來的時間，如果你想滑雪，何不直接住在北海道或阿爾卑斯山;如果想學潛水，直接去到個海島國家; 如果你不想旅遊，就去做你任何想做的工作; 如果你不知道要幹嘛，就趕快多多去體驗這個世界～祝大家都有錢有閒，去實現自己的夢想，讓這世界變得更加美好，掰掰～👋參考資料 Playing with FIRE(Financial Independence Retire Early): How Far Would You Go for Financial Freedom?" }, { "title": "[讀書筆記] 為什麼要睡覺? :睡出健康與學習力、夢出創意的新科學", "url": "/posts/book-note-why-we-sleep/", "categories": "讀書筆記", "tags": "books, psychology, health, sleep", "date": "2021-10-02 23:00:00 +0800", "snippet": "如果有一個產品，只要你使用它，就可以擁有更好記憶力、學習能力、注意力提升、脾氣會變好，不易怒、遠離肥胖及糖尿病及心血管疾病、抵抗力變好不易感冒、不易罹癌、變帥變漂亮、更有吸引力～請問你願意花多少錢購買這產品呢？讓我現在告訴你，免錢！你每天都有機會享受到這些好處，需要做的就只是好好地睡覺～～😴大綱在《為什麼要睡覺》裡，首先解釋睡覺的生理機制，我們的身體是透過怎樣的設計，讓我們感到疲憊想睡，越理解它，才能越知道如何不去破壞它，搞到自己失眠。接著說明在各個方面睡覺帶來的好處，及沒有睡覺的壞處。 睡覺的機制: 身體怎麼知道要睡覺了? 睡覺的過程: 睡著時大腦在幹嘛？ 記憶 注意力 情緒 心血管系統 肥胖 美容覺 免疫力 創造力 如何睡得更好睡眠的生理機制或許我們都聽過或經歷過去旅行有時差睡不著、聽過或使用褪黑激素、喝杯咖啡或茶來驅逐睡意，這些跟睡眠有關的身理機制是什麼，是這本書一開始時要討論的。近日節律也就是常聽到的生理時鐘，我們的身體會有一個近乎24小時的節奏，讓你每天會醒來、想睡，還控制其他節律模式，包括飲食時間、情緒、代謝、核心溫度等等等…而這個身理時鐘在哪裡呢？就是在我們腦中的是視力交叉上核，他每天都會利用大自然之中最穩定的訊號源: 陽光來調校，並透過褪黑激素，來告訴我們的大腦及身體: 天黑了！該睡覺囉～但每個人的週期也可能會偏移，所以有人會是晨型人，而有人卻是夜貓子，因為如此一來有在演化上的優勢，就可以錯開大家睡覺的時間，有人守夜，避免睡覺時被偷襲，增加生存的機會。不過現代社會的作息卻比較適合晨型人，一早要起床上學、上班，所以對於夜貓子也不要太苛刻，他們也不是故意要晚睡晚起，天生的基因讓他們如此，期許在未來的社會裡，可以有新設計的社會制度，讓大家都睡飽飽～腺苷另一種會讓我們想睡的，就是腦中的一個化學物質: 腺苷，從我們一早醒來開始，我們的大腦就會開始累積腺苷，只要我們不睡，腺苷的濃度就會越來越高，而隨著濃度越來越高的腺苷，我們的睡眠壓力就會越大，越來越想睡覺。而有一種物質，會卡住腺苷受體的位置，使我們的腦感受不到睡眠壓力，他就是咖啡因，所以在攝取咖啡因之後，我們的精神會變好，不過只要待身體將咖啡因代謝掉之後，就會開始想睡。咖啡因待謝的速度因人而異，半衰期可能3~6個小時，所以如果你晚上6點喝一杯咖啡，到了12點，有可能身體裡還有一半的咖啡因還沒代謝掉，以至於睡不著。睡覺的組成隨著科技的進步，我們可以記錄睡覺時的腦波腦部活動，得知睡眠有個1.5個小時的週期，每個週期又由非快速動眼睡眠跟快速動眼睡眠組成，越接近天亮的週期裡，快速動眼睡眠的比重會越多。如果你讓自己晚睡或早起，這兩種睡眠少掉的比重就不一樣，我們需要這兩種睡眠，缺一不可，他們各有不同的功能。非快速動眼睡眠此時的大腦，各個腦區協調一致，發出同步且緩慢的腦波，所以需要跨腦區協作的功能跟非快速動眼睡眠息息相關，比如說記憶要將短期記憶轉為長期記憶，需要負責短期記憶跟長期記憶的腦區的溝通;又比如本能的衝動跟理性的控制，也是需要我們的本能腦與掌握高級認知的額葉做溝通，所以如果沒睡好，可能記憶力會變差，情緒容易波動，這些會在下面的章節中詳細說明。快速動眼睡眠此時的腦波看起來就像醒著一樣，掌管情緒及記憶的腦區特別興奮，作夢也是發生在此一階段，在腦內上演各種小劇場，並且偏好把各種不相關的記憶拿來組合，所以跟創造力息息相關。記憶 在學習前的睡眠有助於形成新記憶，學習後的睡眠也能幫助鞏固記憶。我們的睡眠分為短期記憶(工作記憶)及長期記憶，由不同腦區負責，分別為海馬迴及皮質，短期記憶的容量有限，將記憶從短期轉為長期的機制，也還持續在研究當中，不過睡眠一定扮演著重要的角色，能將記憶從海馬迴搬到皮質，以鞏固記憶，並且清空了海馬迴，讓你可以繼續學習新事物，而在這之中，跨腦區溝通的非快速動眼睡眠起到了相當的作用。實驗 - 睡眠之後的學習請兩組人分別記憶100組人臉跟名字的對照，記完之後，一組經歷90分鐘的午睡，另一組不能睡，之後再記100組，對於後面100組事實進行測驗，測驗結果顯示，有經過一晚睡眠的組別比起另一組，多記得了20%的事實。這個實驗針對睡眠之後的學習，指出睡眠能清出工作記憶，有利於我們記住新的記憶。實驗 - 學習之後的睡眠另一個實驗則測試學習之後的睡眠對記憶的影響，一樣先請參與者記憶一份語文資料，在這之後的八小時裡，分別測試睡與不睡，記憶流失的情況，結果發現睡覺組比起不睡組，表現好了20%-40%[1]。注意力很明顯地，睡不飽會無法集中注意力，這點似乎毋庸置疑，每個或多或少都有親身體會過，專注力的短暫喪失，看書看一看，不知道前幾秒鐘讀了哪些東西，恍神發呆頭突然點了一下，如果你在開車，這短短的一兩秒鐘就足以喪命，接著來看看睡眠不足對注意力的影響到底有多大，利用實驗將結果量化，讓我們知道多少程度的睡眠剝奪，對我們人身安全有多大的影響！實驗 - 注意力喪失在實驗室中，用來測量注意力的方法如下: 讓受試者一看到電腦裡亮起的燈，就必須馬上按按鈕，並記錄反應時間，雖然不同程度的睡眠剝奪都有造成反應時間變長，但這裡我們更關心的是完全失去反應的失神，也就是可能出車禍的那個瞬間的次數。實驗結果為，經過一整天連續24小時不睡覺，失神的次數多了400%，如果繼續不睡覺，這個次數可以繼續上升。而每晚只睡4小時且連續6天的受試者，表現跟一整天不睡的人一樣，失神的次數多達了400%，如果連續到11天，則表現跟持續48小時不睡一樣。接下來最令人擔心的是每晚睡6小時的受試者，這也許跟許多人平常的睡眠時間差不多了，在經過10晚的只睡6小時後，失神的次數的表現跟連續24小時沒睡一樣！多了400%，情緒 睡眠不足時，腦中的情緒中心反應會更強烈沒睡飽，情緒會暴躁可能不是沒有原因的，可以看看我們的大腦，在睡眠缺乏時會如何反應。杏仁核，負責威脅偵測、啟動我們身體戰或逃反應的中心，是對於我們生存至關重要的本能機制，當我們遇到危險時，心跳會加速、血壓升高、緊張、集中注意力已準備戰鬥或逃跑，以下一個實驗，就是檢視缺乏睡眠時的杏仁核。實驗 - 情緒反應讓受試者分別觀看不同情緒梯度的照片，從情緒中立的照片比如說一張卓子、一顆蘋果，到有負面威脅感照片，像是著火的房子，張著獠牙的蛇等等…一組受試者是有睡飽的，另一組則沒睡，可以觀測到沒睡覺的受試者，在看到帶有情緒的圖片時，杏仁核的反應多了60%!心血管系統 缺肥睡眠將導至心跳加速、血壓升高、提高冠狀動脈粥狀硬化的機率睡眠不足對於心血管的影響的根本原因，就是它導致了交感神經過於興奮，在許多睡眠缺乏的時候裡，都發現了交感神經的興奮，交感神經是個激動的系統，必要時會使心跳加快、呼吸急促、與增加肌肉張力等功能，使人焦慮繃緊，進入備戰狀態，長時間處於這個狀態就像是車子引擎一直以高速運轉一樣，活塞、油封、排檔等各個部件也會開始損壞。而夜晚睡覺時，又是生長激素分泌最旺盛的時候，生長激素能對身體進行修復，當然也包括我們的血管，睡眠不足對血管造成傷害又減少修復的機會，以致心血管疾病發生的機率的上升。實驗 - 日光節約時間全球性的一場大實驗，約15億人參與，每年從冬令時間轉為夏令時間的那天，少掉了一個小時的睡眠時間，結果隔天帶來心臟病發作尖峰😱肥胖 沒睡飽會更餓、想吃更多、更傾向於吃垃圾食物、且身體捨不得消耗掉脂肪作為能量來源我們的身體有兩種控制食慾的激素，瘦素，及飢餓素，顧名思義，瘦素濃度高時，讓我們感覺飽了沒什麼食慾，飢餓素會啟動強烈的飢餓的感覺，而睡眠不足會使瘦素濃度降低，飢餓素的濃度升高，導致我們吃吃吃～除了吃更多之外，還會無法控制衝動，吃下更多的垃圾食物，睡眠缺乏時，前額葉皮質，也就是能深思熟慮、控制決定的區域，變得不活躍，而較原始的腦部構造，也就是驅動慾望的區域對食物的反應也增強了，這種不在審慎自制而是轉向原始慾望的腦部活動，使我們選擇食物時，傾向吃那些吃起來比較爽的垃圾～最後！睡眠不足時，身體會捨不得捨棄脂肪，所以消耗脂肪以作為熱量來源的比例會變少，基於以上種種原因，對於想要擁有更好的體態的人，一定要好好睡覺呀！美容覺 睡飽飽會更有吸引力!有個實驗室這樣的，讓一群18到30歲受試者分別拍兩次照片，一次是睡飽飽，另一次只睡五小時，之後請一群人來對照片評分，針對的項目有健康狀況、疲勞程度、吸引力。結果出爐～一個人經過一夜短眠之後，較不健康、比較疲倦、且明顯缺乏吸引力，美容覺得以印證！免疫力 睡得越少，愈可能感冒，且對付癌症的殺手細胞數量減少每個人可能都有過經驗，當感冒時，渾身不舒服，只想好好躺下來睡一覺，此時的免疫系統刺激你的睡眠系統，要求更多的睡眠時間，幫助加強戰力！可以知道睡眠和免疫系統之間，有非常密切的雙向關係。實驗 - 噴病毒實驗請一群受試者來到實驗中進行為期一週的實驗，首先往他們的鼻子裡噴了許多病毒，接下來的一週裡，不斷採集血液和唾液樣本，還有鼻涕，利用血液及唾液中的免疫抗體和鼻涕的量來確認他是不是得了感冒。這些人依睡眠量被分為四組，創造力TODO如何睡得更好光線現代生活充斥著各種電子產品，就算到了晚上，燈光通明，看著電視、用電腦、滑手機等等的活動，讓我們一直暴露於光照之下，干擾了我們大腦利用光線來同步近日節律。在該產生褪黑激素，叫我們身體準備睡覺的時候，卻還是很亮！大腦誤以為還沒天黑，以至於晚上難以入眠。到了晚上，減少暴露於光線之下，電腦手機可以使用夜覽模式，減少藍光，調低室內的燈光亮度。晚上的必要照明，可以使用來自水平視線以下的光，因為我們眼睛被設計用來接收光的部分，他的目標是對準著天上的。[2]溫度別在接近睡覺的時間運動，體溫過高將不利於入睡，也可以在睡前洗個熱水澡，利用充滿血液的表面皮膚散熱，降低我們的核心溫度，涼爽的室溫也比溫暖的室溫更容易入睡。心情最後心情要放鬆，腦袋別胡思亂想，不要為明天憂慮，因為明天自有明天的憂慮，或許可以把待辦事項寫下來，透過寫這個動作，清空你的腦袋。做做腹式呼吸或冥想，調整呼吸的速率，來使副交感神經作用，好好鬆一下～～最後祝大家睡得飽、睡得好、睡得呱呱叫，擁有健康的身體及聰明的腦袋，掰掰～～👋參考資料 J. Jenkins and K. Dallenbach, “Obliviscence During Sleep and Waking,” The American Journal of Psichology, Vol. 35, 1924, pp. 605-612. doi:10.2307/1414040 Youtube: Master Your Sleep &amp;amp; Be More Alert When Awake" }, { "title": "RESTful API簡介: 什麼是RESTful? 以及為何需要它?", "url": "/posts/restful-api-introduction/", "categories": "Web Development", "tags": "http, restful api, api", "date": "2021-09-27 20:00:00 +0800", "snippet": "在web開發裡，API是幾乎無所不在，而其中最常見的應該就是基於HTTP協議的RESTful API，這篇簡介跟討論到底什麼是RESTful，為何有它的出現?這是RESTful API一系列文章中的一篇，想了解更多關於RESTful API及HTTP的，可以看這篇目錄:RESTful API Design — A practical guideIntroduction首先，什麼是RESTful，可以說它是一種慣例，一個關於HTTP API如何設計的style，慣例就是並沒有任何的強制性，但當大家都遵守的慣例時，特立獨行的邊緣人可能就會被排擠，至少是難以融入大家的，有了慣例，可以不需要在每次要做事前都要溝通，大家就照著以前一般是怎麼做的做就好。所以你會希望你要使用的API的夠RESTful的，這樣你用起來才方便、好用，你也會希望你開發的API是RESTful的，這樣客戶用起來才會開心。當然你也可以不要，如此一來，客戶要用你的API時，會需要更多地去查看你的文件，他們可能就會覺得麻煩、不開心，你就少了一些賺錢的機會了。所以接下來看看RESTful API到底是長怎樣吧!Resource based首先他是resource based的，也就是每個URL對應到的是一個或多個resource、entity，是名詞，而不會是動詞，比如說下列這樣就是RESTful:/posts -&amp;gt; 代表全部的posts/posts/1 -&amp;gt; 代表某一篇post/posts/1/comments -&amp;gt; 代表某一篇post的所以留言那怎樣不是RESTful呢:/getPosts -&amp;gt; 代表全部的posts/getpostComments/1 -&amp;gt; 代表某一篇post的所以留言Actions有了名詞，那動詞呢？如果想要對資源做一些操作怎麼辦呢？比如說新增、修改、刪除。此時就是使用HTTP的method，GET、POST、PUT、DELETE，分別對應到讀取、新增、修改、刪除。看幾個例子吧!GET /posts/1 -&amp;gt; 取得某一篇文章POST /posts -&amp;gt; 新增一篇文章PUT /posts/2 -&amp;gt; 修改某一篇文章DELETE /posts/2 -&amp;gt; 刪除某一篇文章為什麼RESTful是長這樣呢？基本上RESTful就是verbs x nouns、操作對上資源，因為HTTP有URL代表資源，還有methods，這也是為何基於HTTP的RESTful API自然而然就會長成這樣的原因。但HTTP methods有限，所以通常只會有幾種操作，也就是CRUD，這也是為何常常RESTful API就是對資源進行CRUD的操作，大部分簡單的應用也許這樣就夠了，如果你的應用，無法以簡單的CRUD表示，比如說需要同時對多個資源進行操作才能完成某項任務，那可以需要重新思考如何設計URL，model你的resourse，之後會在後續的文章裡再來討論。若對於HTTP協議還不熟悉的，可以看這系列文章中，前面關於HTTP的部分。Summary大概知道了RESTful API應該是什麼樣子，還有許多細節的部分，會在後面的文章中慢慢討論，比如說URL的設計、如何model resource、documentation、versioning等等…" }, { "title": "[Golang] Common verbs of formatting string", "url": "/posts/golang-common-verbs-for-formatting-string/", "categories": "Web Development", "tags": "golang, formatting", "date": "2021-09-20 15:30:00 +0800", "snippet": "在fmt package裡Printf, Fprintf, Fscanf, Scanf，或像是log package裡的Printf, Fatalf，只要是function名字後面有f的，就能format你的input，以fmt.Printf為例:fmt.Printf(&quot;My name is %s. I am %d years old&quot;, &quot;HoMuChen&quot;, 30)//My name is HoMuChen. I am 30 years old第一個參數將會是最後輸出的字串，不過中間我們可以看到%s、%d的東西，稱之為verb，verb會被後面的參數取代掉，並且是依照你指定的格式，這篇文章將會分享一寫常用的verb。Overview以下為一個常用的verbs表格，依照要format的值的型態做分類，後面再詳細說明: category syntax description general %v value in default format   %T type   %% literal % sign boolean %t true or false interger %b binary   %o base 8   %d base 10   %x base 16   %X base 16 with upper-case letters floating %e scientific notation   %f decimal point but no exponent   %g for large exponents string %s string   %q double quoted string padding %10s width 10 string   %-10s width 10 string left padding   %10d width 10 digit   %010d width 10 digit filled with 0 floating precision %8f width 8 floating number   %8.2f width 8 with 2 digit presicion floating number   %.2f 2 digit presicion floating number General %v: 根據不同的值的型態，預設的格式 type format boolean %t string %s int %d float32,float64 %g %T: 值的型態 fmt.Printf(&quot;The type of this value is %T&quot;, &quot;I am a string&quot;)//The type of this value is stringfmt.Printf(&quot;The type of this value is %T&quot;, true)//The type of this value is bool %%: 真的想要%的時候 fmt.Printf(&quot;%v %%&quot;, 100)//100 % Boolean %t: fmt.Printf(&quot;This is %t&quot;, true) Integer %b %d %x: base 2, 10, 16 fmt.Printf(&quot;base 2: %b, base 10: %d, base 16: %x&quot;, 255, 255, 255)//base 2: 11111111, base 10: 255, base 16: ff Floating point number %e: 科學記號表示 %f: 十進位表示，預設顯示到小數點後六位。 fmt.Printf(&quot;%f&quot;, 123.123456789)//123.123457 %g: 小數點後很多位的話，用%g全部顯示出來。 fmt.Printf(&quot;%g&quot;, 123.123456789)//123.123456789 String %s: 就是字串～ %q: 以雙引號括起來的字串，就不需要再額外寫類似\\&quot;escape掉。 fmt.Printf(&quot;%q&quot;, &quot;I am a string&quot;)//&quot;I am a string&quot; Padding有時我們想要輸出的字串是一樣長度的，可以在前面加上一個數字，代表你想要長度，以下例子: %10s: 寬度為10的字串 users := []string{&quot;David&quot;, &quot;Mu&quot;, &quot;HoMuChen&quot;, &quot;Noname&quot;}for _, user := range users { fmt.Printf(&quot;User: %10s does something\\n&quot;, user)} User: David does somethingUser: Mu does somethingUser: HoMuChen does somethingUser: Noname does something %-10s: 寬度為10的字串，左邊對齊 users := []string{&quot;David&quot;, &quot;Mu&quot;, &quot;HoMuChen&quot;, &quot;Noname&quot;}for _, user := range users { fmt.Printf(&quot;User: %-10s does something\\n&quot;, user)} User: David does somethingUser: Mu does somethingUser: HoMuChen does somethingUser: Noname does something %-7d: 寬度為7的整數，左邊對齊 contentLengths := []int{70, 240, 614, 12345}for _, contentLength := range contentLengths { fmt.Printf(&quot;content length: %-7d bytes\\n&quot;, contentLength)} content length: 70 bytescontent length: 240 bytescontent length: 614 bytescontent length: 12345 bytes Floating point number precision也可以指定浮點數的總長度及小數點後要到第幾位。 %10f: 總長度為10的浮點數，小數點後預設為6位，如果需要超過長度10才能表示，還是會超過。 fmt.Printf(&quot;response time: %10f ms\\n&quot;, 25.35)fmt.Printf(&quot;response time: %10f ms\\n&quot;, 125.35)fmt.Printf(&quot;response time: %10f ms\\n&quot;, 2125.11) response time: 25.350000 msresponse time: 125.350000 msresponse time: 2125.110000 ms //長度超過9了 %.2f: 指定小數點後到第2位。 fmt.Printf(&quot;response time: %.2f ms\\n&quot;, 25.35123)// response time: 25.35 ms %10.2f: 總長度為10，且只小數點後兩位 fmt.Printf(&quot;response time: %10.2f ms\\n&quot;, 25.35)fmt.Printf(&quot;response time: %10.2f ms\\n&quot;, 125.35)fmt.Printf(&quot;response time: %10.2f ms\\n&quot;, 2125.11) response time: 25.35 msresponse time: 125.35 msresponse time: 2125.11 ms Summary在這篇文章記錄了常用的verbs，除了自己忘記可以回來看，也希望能幫助到有需要的人，掰掰～👋" }, { "title": "URL簡介: URL是什麼，由哪些部分組成?", "url": "/posts/what-is-url-and-what-is-it-composed-of/", "categories": "Web Development", "tags": "http, restful api, api, url", "date": "2021-09-13 22:00:00 +0800", "snippet": "這篇文章將會介紹什麼是URL，為何會需要它，以及它是由哪些部分組成的。什麼是URL想像你在一座大城市裡，你搭上一部計程車，想要去你朋友家、你小孩的幼兒園、或是去某某旅館，你必須告訴司機地址; 如果你想聯絡到某人的話，會使用電話號碼; 在政府眼裡每個人有身分證字號。就像如此，每個東西都有它獨特的識別方法，而且是被大家所公認的，也就是你一說，大家就知道你在說什麼，知道你所指的是哪個東西，而在網路上，這種識別方法就是URL(Uniform Resource Locator)，也就是我們在瀏覽器上面常常會輸入的網址，告訴瀏覽器說你想要前往哪個網站，瀏覽哪些資源。URL的組成以這篇文章的網址https://homuchen.com/categories為例，他代表的就是一篇部落格文章的資源，如何跟server溝通，server在哪裡，以及我想要的特定資源: https為傳輸協議，其他還有許多種，比如說ftp、rtsp、ipfs等等… homuchen.com就是host，用來說明存放資源的伺服器在哪裏，透過DNS可以得到機器的IP位置。 /categories是path，用來跟server說你要哪個資源。General URL Syntax一般的URL組成如下:&amp;lt;scheme&amp;gt;://&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;path&amp;gt;;&amp;lt;params&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;frag&amp;gt; component description scheme 用來跟server溝通的通信協議 user 需要登入驗證過的user才能存取資源 password 需要登入驗證過的user才能存取資源 host 一個網域名稱或是IP位置，存放資源的server port server監聽的port，HTTP預設為80，HTTPS則為443 path server藉由path來判斷client想要的是什麼資源，什麼資源要用什麼樣的path，由server自己決定，不過RESTful API會有一個關於path設計的慣例，好讓client不需要記很多或一直看文件，關於後續的文章中會再來討論。 query 以?開始的多對key value pair，每對以&amp;amp;隔開，用來傳送更多的資訊給server，比如說搜尋的過濾條件、影片的開始秒數等等…比如說: ?q=TSMC&amp;amp;sort=time Summary一個URL，是網路上一個或多個資源的身分證，今天簡單地看了URL的組成，對於ㄧ個RESTful API的URL要如何設計，後面再會有詳細的介紹。這是RESTful API一系列文章中的一篇，想了解更多關於RESTful API及HTTP的，可以看這篇目錄:RESTful API Design — A practical guide" }, { "title": "HTTP headers 簡介: 一些常用的headers", "url": "/posts/http-headers/", "categories": "Web Development", "tags": "http, restful api, api, headers", "date": "2021-09-05 00:00:00 +0800", "snippet": "在HTTP協議中，headers對於每個request，response提供了一些額外的資訊，基本上他們就是只是一對key value pair，由冒號(:)隔開，今天會看看HTTP協議的格式，header在其中的位置，以及介紹一些常用的header們。HTTP messagesHTTP是一個text based的傳輸協議，general的HTTP request message如下：&amp;lt;method&amp;gt; &amp;lt;URL&amp;gt; &amp;lt;version&amp;gt;&amp;lt;header&amp;gt;......&amp;lt;header&amp;gt;&amp;lt;body&amp;gt; 而HTTP response message如下：&amp;lt;version&amp;gt; &amp;lt;status code&amp;gt; &amp;lt;status message&amp;gt;&amp;lt;header&amp;gt;......&amp;lt;header&amp;gt;&amp;lt;body&amp;gt; 可以看到中間部分是由許多行的header所組成，而每一行header是一對key value pair，由冒號(:)隔開，每個key或value通常第一個字會大寫，然後用-隔開，比如說:Connection: Keep-AliveContent-Length: 10000Content-Type: text/htmlDate: Thu, 02 Sep 2021 02:52:46 GMT如果對於HTTP message format還不熟或想要有更多了解的，可以看我之前寫的文章: HTTP 簡介，以及使用telnet、nc、curl等指令來探索常用的HeadersHeaders對於每個request，response提供了一些額外的資訊，他們就只是一對key value pair，由冒號(:)隔開，你可以放任何你想放的header上去，不過就是除了你自己的之外沒人看的懂而已，今天我們只討論一般大家約定俗成的header們，以下將他們大致分成幾類: category header description General Date The time the message was created   Host The hostname and port to which the request is being sent   User-Agent The name of the application making the request Payload Content Content-Type The type of object that this body is   Content-Length The length of the body   Content-Encoding The encoding of the body   Location Where the entity is really locatied at Conditional Request ETag The entity tag associated with this entity   If-Match Get the entity if it matches the tag   If-None-Match Get the entity if it does not match the tag   Last-Modified The last date and time when this entity changed   If-Modified-Since Get the entity if it has been modified since the specified date Connection Connection To specify options about the request/response connection General Headers Date: 說明這則HTTP訊息被創建出來的時間。 Host: Request要被送去的server目標，你可能會納悶為何會需要這資訊?不是已經透由TCP/IP跟server建立了連線了嗎？這是因為 User-Agent: 說明發出request的client是什麼，可能是各種瀏覽器，或者是curl。 Payload Content不管是request還是response，body可能會帶有一些資料，關於這些資料的訊息在此一分類討論如下: Content-Type: 用來說明body裡的資料是什麼格式，常見的像是html檔案的text/html、csv檔案的application/csv、圖片可能是image/jpg、你的API可能用的是application/json等等，如果沒有Content-Type，收到資料的一方將不知道該要如何處理這些資料， 至於要用哪種type可以在這查詢MIME 類別 Content-Length: body裡的資料總共有幾個bytes。 Content-Encoding: body裡的資料是什麼ecoding。Conditional RequestsClient可能在之前已經取得過相關的資源，並且保有一份備份，如果此資源沒有更新時，可以不需要透過網路在傳輸一次，以節省時間及頻寬。相關的RFC: RFC 7232 “HTTP: Conditional Requests。 ETag: Response中，對於回傳的資料加的一個tag，有點像是以資料為輸入的hash值，讓client後續使用，會在If-Match及If-None-Match，以下說明。 If-Match: Server只有在match時，才會動作，通常在PUT操作時用於避免lost update的問題，比如說你想編輯一頁Wiki的內容，你先要求了本來的頁面，server回傳了Etag: A，當你編輯完送出時，帶上If-Match: A的header，只有當內容還是A版本時才會更新成功，如果在你編輯的時候有人已經先更新了頁面內容，則會回傳412 Precondition Failed，如此一來，避免你的更新會蓋掉別人的更新。 If-None-Match: Server只會在沒有match時，才會回傳資料，因為如果match就代表client擁有的資料的copy還是最新的，就回傳304 Not Modified。 Last-Modified: Response中使用，用來說明回傳的資料最近修改的時間，好讓client可以cache起來並搭配If-Modified_Since來更新，詳情見下面。 If-Modified-Since: Request使用此header來決定cache有沒有過期了，比如說上次拿取資源時server response了Last-Modified: Sun, 05 Sep 2021 01:40:14 GMT，這次在request相同資源時，就可以帶上If-Modified-Since: Sun, 05 Sep 2021 01:40:14 GMT，如果在2021-09-05這時間之後，資料並沒有更新，則server可以回傳304，client就能直接使用cache，而不需要再透過網路下載資料，反之，資料有更改的話，就回傳新的資料並帶上新的Last-Modified。Connection Management Connection: 每個HTTP request都需要仰賴TCP先建立一個連線，而每建立一次TCP連線都需要三向交握，至少需要花費一個RTT(Round trip time)的時間，所以當你有多個request的時候，你會希望TCP建立一次連線就好，之後可以重複使用，所以可以加上Connection: Keep-Ailve，告訴server，你希望在HTTP response回傳完之後，不要斷掉TCP連線，不過server可能會不鳥你，就會回你Coonection: Close。Summary今天簡單看了許多header的用途，還有其他好多好多的header～等遇到了再去了解吧！這是RESTful API一系列文章中的一篇，想了解更多關於RESTful API及HTTP的，可以看這篇目錄:RESTful API Design — A practical guide參考資料 HTTP headers MIME 類別 RFC 7232 “HTTP: Conditional Requests" }, { "title": "幾個我常用的vim的功能", "url": "/posts/some-vim-commands-I-often-use/", "categories": "Web Development", "tags": "vim, linux", "date": "2021-08-30 22:00:00 +0800", "snippet": "作為一個軟體工程師，我們花在文字編輯器上的時間一定佔了一定的比例，更精通熟悉我們使用的編輯器的話，開發的效率可以提升很多，今天就來分享一些我蠻常會用到的vim的功能～IntroductionVim是一個modal editor，可以切換在各個模式之間，一開始時是在normal mode，今天要介紹的功能，都是在normal mode下操作的，按i或a可以進入insert mode，按esc即可以退回normal mode。我通常比較常使用a，因為當把指標移到最後時，用a可以直接在最後面開始輸入。Navigation上下左右最基本的就是k、j、h、l分別對應到上下左右翻頁覺得上下按著這樣太慢，可以用Ctrl-U、Ctrl-D來上下翻頁行首、行末0指標會跳掉當行的最前面，$則是最後面。字的跳躍w可以跳到下一個字的開頭，e則是跳到下一個字的結尾，b則是往前跳到前一個字的開頭。() [] {} 跳躍指標找到了一對括號的其中一個，想要到另一個的話可以用%。搜尋跳躍將指標放在字上，按#，就會自動幫你搜尋，並跳到相同的字上，效果相當於用/搜尋再按n。Deletion刪除一個字母x，可以刪除指標上的那個字。刪除一行dd，刪除指標所在的那一行。刪掉指標後的所有字D，常用狀況像是複製了一行method，然後刪掉method name跟paramters再打新的。如下圖反白部分:d + {navigation key}搭配上面提到的各種navigation的方法，比如說: dw : 刪掉一個字，從指標到字的尾端，像是下圖反白的部分。 d% : 刪掉整個(…)、[…]或{…}di diw：跟dw也是刪掉一個字，但是可以刪掉整個字，效果就相當於先按b讓指標回到字首再dw。 di&quot; or di( or di[ or di{：刪掉”“內、()、[]及{}的所有字。 di( or di)即可刪掉()中function的paramter di&quot;則是刪掉雙引號中間的所有字，留下雙引號 dada的話跟上述di都ㄧ樣，只不過會將引號或括號都一併刪除。d 換成 c將上面的d都換成c，可以有一樣的功能，差別就是會直接進入insert mode，所以可以省去一個按i的時間。如cw、ciw、ci&quot;、ca(。Copy and Paste複製一行yy複製一行，p貼上y + {navigation key}y一樣可以搭配上面提到的navigation key來複製 yw，yiw: 複製一個字 yi&quot;: 複製雙引號內的字 y%: 複製成對括號內的字稍微簡單地紀錄一下及分享，希望能有幫助～～ 掰掰～👋" }, { "title": "Introduction to HTTP Response Status Codes: How to use them correctly?", "url": "/posts/http-response-status-codes-how-to-use/", "categories": "Web Development", "tags": "http, restful api, api", "date": "2021-08-22 22:00:00 +0800", "snippet": "這篇文章會介紹在HTTP協議中，Response status code的作用，有哪些codes以及該如何去使用他們？這是RESTful API一系列文章中的一篇，想了解更多關於RESTful API及HTTP的，可以看這篇目錄:RESTful API Design — A practical guideClient Server ModelHTTP是一個Client-Server的架構，客戶端發送一個request，而伺服器端接收到這個request，可能做了些事後，必須給個回應，不然客戶端會不知所措，到底你有沒有收到我的請求呢？我的請求是合理的嗎？那最後的結果是成功還是失敗，不管怎樣，總要給個回應吧。所以在HTTP Response的格式中，第一個就是Status Code，用來簡短地表示請求處理的情況，在大部分常見的簡單請求中，可能可以只看這個Status code，就知道server處理的情況是如何。如果還對HTTP response message的格式還不了解的，可以參考先前的文章: HTTP簡介Status Codes大致可以將code分為四類，分別以2、3、4及5開頭。 2開頭: 代表請求成功。 3開頭: 需要client在做其他動作，比如說去GET別的URL，或只是content沒變，從cache裡拿就好。 4開頭: client request有問題，syntax有問題或是server看不懂，少了某些參數之類的。 5開頭: server這邊出了一些問題拉～ Status codes Description 2xx Good! 3xx Redirection 4xx Client你的錯 5xx Server我出錯惹 接下來我們就來看看一些常見的status code吧！2xx 200 OK: OK就是OK! 如果你不知道用什麼，但你要表達請求成功了，那就用200吧～😂 201 Created: 當request是PUT，要求創建資源時，顧名思義，可以使用201代表資源成功被創建，可以在response body裡return整個資源，可以在header Location上，加上新創建的資源的位置。 202 Accepted: 代表你成功接受了請求，然後會asynchronously地處理。 204 No content: 沒有response body，會用到情境像是使用POST或PATCH做update時，成功的話，server沒有額外的資訊需要return給client知道。 3xx 301 Moved Permanently: 要求的資源已經搬家了～資源新的位置一般放在Location header中。 302 Redirect: 跟301一樣，會在Location中放上新的URL，跟301不同的是，301是永久性的，就是說舊的URL他之後都不會用了，希望用新網頁來取代舊的，而302是暫時的，可能這次有個活動，暫時將頁面導到另個地方，之後有別的活動，又換到新的地方，但他還是client繼續使用原本的URL。 4xx 400 Bad request: 請求的內容有誤，或是server看不懂。 401 Unauthorized: Authenticate失敗，例如帳號密碼打錯呀，Token不對呀。 403 Forbidden: User有驗證成功，但他沒有足夠的權限來做這個請求。 404 Not found: 請求的資源不存在！ 405 Method Not Allowed: 對於請求的資源，不支援所要求的method。 5xx 500 Internal Server Error: Server掛掉拉～Summary要使用適當的status code，避免溝通上的誤會，因為可能有懶惰的client看到status code就下了某些判斷，所以別特立獨行，給你的API的使用者驚喜🎉🙀" }, { "title": "[讀書筆記] 金錢心理學: 打破你對金錢的迷思，學會聰明花費 (下)", "url": "/posts/book-note-dollars-and-sense/", "categories": "讀書筆記", "tags": "books, finance, psychology", "date": "2021-08-21 23:40:00 +0800", "snippet": "繼上篇[讀書筆記] 金錢心理學: 打破你對金錢的迷思，學會聰明花費 (上)談完部分的內容之後，今天在這把剩下講完吧～大綱以下為這篇文章的大綱 定錨效應 稟賦效應 期望公平 太在意價格 總結及我如何利用以上現象來設計自己定錨效應我們首先先來看一個實驗，請一群受試者回答一個問題: 非洲國家佔聯合國國家的百分之幾?大部分人對這個答案的數字都沒什麼概念，但這實驗讓受試者在回答之前，先轉一個被設計過轉盤，這轉盤只會出現25及65這兩個數字，結果發現轉到25的那群人，回答的答案平均是;而另一組則是!沒有任何原因，我們就是會受到環境影響，會被最一開始的資訊影響，這就是定錨效應，哪怕他毫無意義，毫無邏輯。而這些資訊從哪裡來呢？除了在環境中不小心跑進來的之外，主要還有其他兩種，自己過去的經驗以及跟著大眾的腳步。自我因循問你一瓶可樂多少錢？大概30塊，為什麼定這個價呢～其實也沒有什麼理由，就是因為過去我們看到的價格就都大概是這樣，人們會相信自己也是天經地義的事，只是有時自大就是這麼來的。從眾在《影響力》一書裡，說明了許多我們人類做出決策、行為時，會受到許許多多各種因素的影響，而其中一個就是從眾，尤其是當我們對一件事物越不了解，所知的資訊越少時，就更容易跟著身邊大眾的行為一起行動，畢竟我們人是社會性的動物，一般來說，我們不希望被說成是特立獨行、不易合作、自私自利，我們會希望融入群體之中。稟賦效應我們會對於我們擁有的東西，賦予它更高的價值，這就是稟賦效應，可能是我們對它了解的更多，知道它的價值;或者我們對它投注的心力越多，就更加愛它．所以舉凡像是免費試用、體驗，拍得讓你身歷其境的廣告，都是讓你有種擁有那事物的錯覺，好像你願意掏出更多的錢．甚至是競標，當你一直是最高價的暫時得標主時，你腦中可已經有了各種拿到東西後的幻想，在最後一刻被別人出了更高價時，你可能就腦衝再給它加價下去。而從另一面來看，因為我們我們所有的事物估值較高，所以比起獲得，我們也會盡量避免失去我們已經擁有的東西，即便它們客觀上的價值是一樣的．損失趨避讓我們來玩個遊戲，擲一面硬幣，正面的話你可以獲得十萬塊，反面則需要付出十萬塊，你會想參加嗎～我想大部分的人都不會參加，因為失去十萬塊的痛苦大於得到十萬塊，使得原本從理性經濟人眼裡看來參不參加都一樣的事產生了變化，所以就會有人股票賺一點就獲利了結，而套牢很久卻都不賣，有獲利怕又還回去所以趕快賣掉，而虧損只要不賣，就不算損失，一張不賣！奇蹟自來！期望公平我們人類喜歡公平甚於自利，先來看看以下這個實驗吧～ 實驗中請來兩個人，並給他們一筆錢要他們分配(比如說100元)，其中一個人可以決定要如何分配，而另一個人可以選擇接不接受，但要是不接受的話，大家都沒錢拿～當提議方提出50:50的時候，沒有問題，很公平，但當提議方提出90:10的時候，另一個人卻會選擇拒絕，就算拿到10元比起什麼都沒有還要好，但他還是拒絕了!在《社交天性》一書裡有說到，社會獎賞跟生理獎賞對我們的大腦來說，其實沒有太大的區別！我們渴望著兩者，也有類似的神經迴路，社會性獎賞就是比如說上面提到的公平、信任、被認可、被讚美等等，而生理獎賞就像是吃飽喝足、得到十萬塊，因此我們會選擇公平而不是10塊錢，因為對我們人類來說，公平也是有某種程度的價值的。另外還有哪些地方有這種重視公平甚於實際效用的出現呢？比如說雨天雨傘漲價，讓你寧願淋雨，也不願花一個錢來獲得遮風擋雨的效用;Uber在颱風天漲價，也可能讓你不叫車！因為他們不公平！趁火打劫，剝削我們！儘管這些花費會帶來好的實際效用。太在意價格當我們對一項事物了解的越少，或者可以得到的資訊無法量測時，我們能仰賴的資訊就可能只剩下價格，所以有時會有越貴就是越好的迷思，一晚只要500的五星大飯店你敢住嗎？一隻大龍蝦只要500你敢吃嗎～我們喜歡確定可量測的事物，面對太未知或負責難以衡量的情況時，會去找個相對簡單的指標來做判斷，像是我們的人生好難好複雜，不知道要做什麼該追求什麼，所以有時就陷入賺越多錢越好的情況中，變成太過於只追逐金錢。總結看完這本書後，知道了如此多人類行為可能會不理性之處，唯有先察覺到，才有辦法做改進，又或者是不需要改進，只是可以利用這些心理因素，來讓我們花費所換得的快樂可以最大化。看完這本書之後的我，如果未來有出去旅行的機會，可能會更多地選擇將行程的花費預先的支付掉，如此一來在旅行當下，你可以不用感到付錢這個動作的痛苦，將心思好好地集中在這躺旅途的體驗上，像是購買度假村的吃到飽方案，你就不會在游完泳之後，是否要在海灘邊點個點心飲料間猶豫;也不會在晚餐時，怕太貴而不敢開瓶紅酒來喝，雖然吃到飽方案整體下來的花費可能會更多，但卻能換來更好的旅遊體驗。相反地，在平時，也許你會想體會到更多的付錢之痛，這樣你才不會多做了一些無謂的消費，所以我在每次要付錢時，不管是用現金、信用卡還是行動支付，當下就會拿起手機來記帳，除了放大了花錢的感受，也讓花錢變得更加困難一些。(我如何記帳的可以參考我先前的文章: [Google Sheet]我如何利用Google表單來記帳)另外如果你本來想買什麼沒用的小廢物，如果忍下來的話，可以把省下來的錢記到另一個帳戶中，可能是旅行呀、買房，或其他你的夢想上，讓自己省錢的習慣有更多的動力，帶來一些立即的滿足回饋，在《原子習慣》中說到，想要改掉一個習慣，就要讓它難以去做，想要培養一個好習慣，就要讓這個習慣有獎賞。這類研究，是屬於一個叫做行為經濟學的領域，與經濟學不同的是，在經濟學裡，假設了每個參與其中的人都是理性的，像機器一樣，一定會符合自身的最大利益來做決策，然而結合了心理學，希望能有更準確，更貼近現實的模型來描述各種經濟決策。" }, { "title": "How to stream data from Blob Storage at your HTTP server using Azure and express.js", "url": "/posts/how-to-stream-data-from-blob-storage-at-http-server-using-azure-and-express/", "categories": "Web Development", "tags": "express, node.js, azure, stream, http, api", "date": "2021-08-13 23:30:00 +0800", "snippet": "這篇文章將會示範如何使用Node.js來下載Azure Blob Storage上的檔案，並且使用Stream的方式，將檔案儲存到本地端，或是當你作為一個Server(此篇使用express.js)時，回傳給你的client，並且根據檔案名稱來設置正確的Content-Type．Download file from Azure取得file的Readable Streamconst { ShareServiceClient, StorageSharedKeyCredential } = require(&quot;@azure/storage-file-share&quot;);const ACCOUNT = &#39;your storage account&#39;;const ACCOUNT_KEY = &#39;your account secret&#39;;const credential = new StorageSharedKeyCredential(ACCOUNT, ACCOUNT_KEY);const serviceClient = new ShareServiceClient( `https://${ACCOUNT}.file.core.windows.net`, credential);//下載data share裡的d4ba71bf-3d38-4e69-9ba2-be4c04179e43.csvconst fileClient = serviceClient .getShareClient(&quot;data&quot;) .rootDirectoryClient.getFileClient(&quot;d4ba71bf-3d38-4e69-9ba2-be4c04179e43.csv&quot;);const downloadFileResponse = await fileClient.download();//downloadFileResponse.readableStreamBody ----&amp;gt;&amp;gt; Readable Stream在這裡拉Write to local file or socket把檔案寫入到本地的檔案使用fs.createWriteStream(path)建立一個file的Writable stream，再將Readable Stream pipe到那裡．const fs = require(&#39;fs&#39;)const filename = &quot;local.csv&quot;downloadFileResponse.readableStreamBody.pipe(fs.creatWriteStream(filname))把檔案傳到HTTP Response (express.js)express的handler裡的第二個參數response物件，也是一個writble stream，可以直接將資料pipe過去．app.get(&#39;/path&#39;, (req, res) =&amp;gt; { downloadFileResponse.readableStreamBody.pipe(res)})Content-Type使用套件mime-types，可以從想要下載的資料的檔案名中取得MIME type，從而設置到HTTP Response的Content-Type header裡．const mimeTypes = require(&#39;mime-types&#39;);const filename = &quot;test.csv&quot;;const mimetype = mimeTypes.lookup(filename);console.log(mimetype) //text/csvSummary最後將以上結合起來，完整的代碼如下:跑起來之後，就能透過GET http://localhost:3000/share/filename.csv這樣之類的網址來下載檔案囉～～參考資料 Node.js documentation: Stream @azure/storage-file-share" }, { "title": "[讀書筆記] 金錢心理學: 打破你對金錢的迷思，學會聰明花費 (上)", "url": "/posts/book-note-money-psychology/", "categories": "讀書筆記", "tags": "books, finance, psychology", "date": "2021-08-07 23:30:00 +0800", "snippet": "生而為人，而不是一部機器人，我們有情緒，我們有人性而不是聖人；我們懶惰，喜歡走捷徑，有各種誤判及偏見；我們的認知有限制，腦袋的容量非常有限；我們短視近利，喜歡立即得到獎賞及滿足；我們有各式各樣的思考、認知、感覺，進而有了相對應的行為，這些就是心理學在研究的事．當這些人的天性碰上了金錢，我們是否能做出好的經濟決策呢？會不會當了許久的冤大頭而不自知，或是被誘惑引導到花了一些本來不會花的錢，該如何聰明的花費、花得剛好、花得開心，就是《金錢心理學》這本書要探討的內容．大綱以下為這篇文章的大綱，由於內容較多，部分的章節會在下一篇文章裡再談～ 基本原則: 機會成本 相對性 心理帳戶 避免痛苦 定錨效應 稟賦效應 期望公平 太在意價格 總結及我如何利用以上現象來設計自己基本原則: 機會成本一顆蘋果跟一顆橘子給你選，你要哪個？對大部分的人來說，這都不會是個非常困難的選擇，但如果是一顆蘋果50元，跟一顆橘子10元呢？感覺是不是變困難了~這是因為機會成本變複雜了的關係，在第一個情況中，如果你選擇了蘋果只需要放棄橘子，機會成本只有蘋果或橘子，但在後者，如果你選擇了蘋果，你的機會成本可能是任何50元可以買到的東西，可能是五顆橘子、一杯飲料、一個漢堡、兩本筆記本、好多枝筆、等等等無限的可能～所以當一件事涉及到了金錢的時候，就會變得更為複雜，最理想的情況是，我們在做決策時必須考慮到所有的機會成本，但這既困難又不太實際，我們不可能在得到想到所有可能的資訊之後才下決定，往往我們會被其他各種心理因素給左右，以下就一一來看吧！相對性艾賓浩斯錯覺首先我們先來看一張圖，大家會覺得兩個在中間的橘色圓形圖案，哪一個比較大呢？是否會覺得右邊的比較大呢？但其實是一樣的! 這就是艾賓浩斯錯覺，是對相對大小感知的一種視力錯覺．金錢的相對大小所以我們的大腦這種對相對大小的感知，也一樣會應用到金錢上．先來看一個情境:假如今天你想要買一雙鞋，要價2000元，然後店員跟你說，再走路五分鐘的路程之外有一家分店，只要1800，那你會去另一個店買嗎？再來，今天假設你要買的的是一台電視，要價20000，然後店員也跟你說，走路五分鐘的路程之外有一家分店，只要19800，那你會去另一個店買嗎？我想有人在第一種情況會選擇去另一家店，而買電視時卻不會，但一樣都是五分鐘路程省200，照理說兩種的選擇應該要一樣才是呀～在這裡就是對相對大小的認知偷偷溜進了我們的判斷之中，一樣的200塊，相對於2000感覺省了不少，但相對於20000，好像就沒那麼多了．另外還有許多地方，像是買車時，推銷員建議只要再加多少錢，就可以升級某某配件;或是在各種商店的收銀櫃台上的小物，相較於你全部買的東西，再多花個幾十塊買一些零食好像也沒什麼;以及在高級餐廳裡開一瓶高價的紅酒，這些可能都是商人利用了相對性而促使你做了原先你不會做的交易．誘餌我們人類喜歡比較，那也無可厚非，因為有時不能比較的話，時常無法做出決定，比如說要你對一堂線上課程出價、一顆花椰菜要多少錢、500公克的牛肉要多少錢，如果沒有其他資訊，往往不知道該怎麼定價，所以有時商人為了讓你更容易做出決定，故意給你可以比較的內容，讓你覺得好像賺到了，比如說原價1000，今天特價600！我們可以看看經濟學人雜誌是怎樣做的，訂閱的選項有三種：線上版、印刷版、線上加印刷版，定價分別為59美元、125美元、125美元，什麼？！單純印刷版跟線上加印刷版都一樣只要125美元，傻子才會只訂印刷版．沒錯！確實沒有人是傻子，雙訂閱的人數佔了84%．現在我們把傻瓜選項拿掉，只有線上版及雙訂閱，結果選擇雙訂閱的人只剩32%！加上一個無關緊要的選項，竟然讓大家選擇了更高價的選項，這是因為在比較單純印刷版及雙訂閱的時候，一樣的價錢，雙訂閱明顯優於印刷版，有東西可以比較的時候，我們人類就是比較開心，覺得賺到！心理帳戶錢就是錢，每一分錢應該都是一樣的，並不會有所不同，但我們有時卻會替錢分類，讓我們先來看看以下這兩種情境: 今天你已經買了一張一千塊的球賽門票，比賽當天，興沖沖地到了球場，卻突然發現票不見了！這時你會在現場再掏出一千塊來買票嗎? 你沒有預先買票，到了球場時發現你錢包裡的一張一千塊鈔票不見了！此時你會在現場拿一千塊來買票嗎？我想大家對於第一種情況，要再掏錢出來買票應該比較掙扎吧～明明我們損失的都一樣是價值一千塊，不管他是門票還是鈔票，但我們的感覺卻不同，後續的行為也可能跟著不同．因為我們預先幫我們的錢分類了，在第一種情況裡你買門票用的錢，可能被你歸類在娛樂帳戶上，而第二種情況的錢是沒分類的一般預算，也許你心想每個月能花在娛樂上的預算有限，用掉了沒了，所以當損失的是娛樂帳戶裡的錢，就不太能再花更多錢在此項目了．認知限制會做這樣的預算編列，並不是壞事，就像前面所說的，如果要花一筆錢時，要考慮到所有的機會成本幾乎是不太可能，我們的大腦裝不下所有選項，但一旦我們將預算分類，此時機會成本的選項就會變得少許多，可以更容易做出決定．以娛樂預算為例，當你要花錢去看一場球賽時，你可能會想是要看一場球比較值得呢？還是去看兩場電影？或者省下來之後再帶女朋友一起出去旅行？不好的心理帳戶既然心理帳戶有助於我們做決定，那不好的地方在哪兒呢？有時我們會把錢的來源，不小心也分類了，是辛苦賺來的錢、還是發票中獎、或者是出差可以報帳，住了一個比較好的飯店，然後自己多花錢吃了豪華晚餐．對於比較輕鬆得來的錢，我們就更容易不假思索地花掉，其實錢就是錢，都是一樣的~避免痛苦人類天生就會試著避開痛苦，當我被熱水燙到，就知道下次要避開，被蛇咬一次，就會十年怕草繩，跟金錢有關的痛苦，就是把錢付出去，交給別人的那個瞬間！於是乎，商人就發明了一些方法，來讓我們更少地感知到付錢的痛苦，讓付錢的時間跟享受商品及服務的時間錯開，或是讓我們在付錢時，感覺好像付的不是錢XD工具使用信用卡這類工具，可能會讓有些人不小心花了更多錢，在網站上逛逛，一鍵付款，付錢的過程太過方便無痛．時間上透過實際付錢跟享受的時間差，讓我們忘記付錢這件事，可以將付錢的時機大致分為三類，預付、後付或邊用邊付、什麼時候付錢真的會影響我們花錢的多寡嗎？有個實驗是這樣的:請一群人來實驗室待四十分鐘，然後給他們一筆錢，他們可以選擇將這筆錢花在看有趣的影片，但是比較貴，也可以看一些漫畫，這比較便宜，或是有提供一些免費乏味的學術研究給他們看，總之他們可以選擇怎麼用這筆錢，來度過這漫長的四十分鐘．而付錢的方式就是分成三種預付、後付、邊用邊付: 預先想好要哪些娛樂，提前支付 在實驗期間，使用娛樂，結束後再支付 在實驗期間，每要使用一項娛樂時，當下付費結果，預付跟後付沒有明顯差別，但是邊用邊付組則是花了最少的錢～所以可以藉由時時提醒自己付錢的痛苦，來減少不必要的花費，就像我在[Google Sheet]我如何利用Google表單來記帳這篇裡，透過記帳，讓自己就算是使用電子錢包、網購、用信用卡時都能感受到付錢之痛．剩下的內容，下集待續，掰掰～～ 👋" }, { "title": "[Google Sheet]我如何利用Google表單來記帳", "url": "/posts/google-sheet-how-to-do-bookkeeping/", "categories": "Google Sheet", "tags": "finance, google sheet, google form", "date": "2021-07-31 22:30:00 +0800", "snippet": "利用Google sheet及Google form來客製化自己的記帳App，表單的連結可以放到手機桌面，就像一般App一樣，每次花費的紀錄，將儲存在試算表裡，後續可以做任何你想要的統計分析．建立表單首先建立一個新的表單，接著點選工具 -&amp;gt; 建立表單，就會在新分頁裡跑出一個空白表單，接著我們就要編輯他的內容．編輯表單命名表單，隨便你要打什麼，這裡就打個”記帳”，接下來的每個問題可以是簡答、單選題、多選題這裡的第一個問題的題目就是項目，也就是我們花了什麼錢，題目的種類選簡答:第二題題目題目為金額，也是簡答，填表單時記得填上數字第三題題目題目為種類，選項就你開心怎麼分類～ 這裡的例子是食衣住行娛樂跟其他後面你想要加上任何題目都可以將表單加入主畫面完成表單後，點選右上角的傳送，就可以在你的手機瀏覽器中，打開這個網址．點選右上角表單裡面的加到主畫面，就能像是Appㄧ樣，在桌面有個小圖示囉～檢視成果每次在表單送出的資料，都會收集到Google Sheet中，如下圖:之後就能利用這些進行各種你想要的統計圖表拉，比如說每天花多少錢在哪些分類上，總共各分類的佔比為何:Summary建立好表單之後，每次要花錢的時候，就打開手機，送出一個表單就能記帳啦．在金錢心理學也有說到，我們人類天生會避免痛苦，而付錢就是一種痛苦，所以商人會有許多方法來讓我們忘記痛苦，不小心就花太多錢，比如預付、後付、信用卡、一鍵購物，讓花錢變得越方便，越無痛，來使得我們花更多．所以記帳這行為，不僅是用來追蹤我們消費狀況的一個工具，說不定也能讓我們減少不必要的花費，每次花錢時都會清楚地感受到錢噴出去的感覺，哪天更可能因為懶得拿出手機來記，就不花錢了呢～延伸閱讀 [讀書筆記] 金錢心理學: 打破你對金錢的迷思，學會聰明花費 (上) [讀書筆記] 金錢心理學: 打破你對金錢的迷思，學會聰明花費 (下)" }, { "title": "[讀書筆記] 習慣致富 人生實踐版", "url": "/posts/book-notes-effort-less-wealth/", "categories": "讀書筆記", "tags": "books, finance, habit", "date": "2021-07-24 22:30:00 +0800", "snippet": "簡介這本書的第一章到第十六章，作者講述了兩對夫婦的故事，從交往、訂婚、結婚、蜜月，講到租房、買房、小孩教育、生活中的各個面向，看他們在面對所有財務決策時，如何做不同的選擇，而這些習慣，經過了時間了累積，到最後產生了巨大的差別！透過故事，像是看小說一樣，更容易地會去感受到那些習慣的重要，那對底是哪些習慣呢～作者在本書後面的22章一一闡述: 擁有好習慣，人生是彩色的；擁有壞習慣，人生是黑白的 慎選人生伴侶 避免欲望型消費 節儉，但不小氣 避免隨意購物 成為自己的人生設計師──建構藍圖或計畫 持續投資你的儲蓄存款 謹慎投資 讓你的錢各自歸位 勿陷入「生活方式升級心理」，勿將你的生活加大升級 保持心胸開放，別讓偏見影響你的財務決定 結交有儲蓄習慣的朋友 為你心中最重要的東西儲蓄 金錢等於自由 財富自由的首要條件是身體健康 創造多元收入金流 富裕不只是金錢富裕──七種富裕類型 變有錢並非單一事件 好目標 V.S. 壞目標 好習慣帶來好運，壞習慣帶來厄運 財富消除五十八%的人生問題（與壓力） 財富遊戲計畫心得感想或許可能會覺得這些東西都是老生常談，陳腔濫調，但就像伏爾泰說過的 Common sense is not so common在我們日常生活中，是否這些習慣對富人來說是common sense，但對我們卻不是，或者是我們知道他是簡單的常識，卻沒有落實到生活當中，使他們變得平常，透過這次的閱讀，可以檢視自己有哪些是做得不好的部份．不過在這本書裡，對於每一個原則及習慣，講的篇幅有限，我覺得可以透過其他的資源來加深學習: 習慣: 習慣這兩個字就出現在書名當中，可以知道它有多重要，造就現在我們的狀態的，正是過往以來我們所有的所作所為，而我們在過去的每個當下所做的選擇、所做的行為，絕大部分並不是我們有意識的，而是無意識的習慣！ 試想從我們早上醒來，睜開眼睛第一件事是拿起手機賴在床上滑，還是整理床鋪、冥想;早餐是隨便吃吃，還是有注重均衡營養;到了工作場所，是先想好今天最重要的任務，還是開始瞎忙;下班之後是躺在沙發上看電視，還是去運動． 我們不會無時無刻都在努力地做選擇，而是讓習慣驅動著我們，而《原子習慣》這本書，說明了習慣的機制，教我們如何去培養好習慣、除去壞習慣，而不是每天依靠意志力來控制自己，而最後又筋疲力盡地失敗． 人際關係: 《人性的弱點》，經典． 睡覺: 《為什麼要睡覺》，如果有一種產品，可以讓你記憶力變好、更具創造力及生產力、降低罹癌機率、心情更好、走出傷痛、變美麗、皮膚變好、變苗條，那你願意花多錢買這產品呢～一萬？不用！五千？也不用！免錢的啦～～只要你每天晚上好好地去睡覺就有了！為什麼要睡、要如何睡？比爾蓋茲也推薦大家看看這本書． 運動: 運動對我們到底有多少好處，在《真正的快樂處方》這本書裡，針對運動對我們大腦的影響，如果你想要變得更年輕、聰明、學東西更快、壓力更小更快樂、注意力更集中、更有創造力嗎？那就運動吧！ 財務決策: 本書說我們要有儲蓄及投資的習慣，在現在金融越來越越發達的世界當中，我們有越來越多的行為牽涉到金錢，在花錢時時常有許多不理性的行為，可能是被商人誘導，要讓我們花更多的錢，或者只是我們自己懶，在《金錢心理學》裡，讓我們從很多的故事及實驗中，覺察到自己到底有沒有亂花錢的地方． 最後除了自己做，最好是身邊的朋友及伴侶都有相同的價值觀，才能一起前進，而不是處處拉扯，祝大家可以找到三觀合的另一半~ 😂延伸閱讀[讀書筆記] 為什麼要睡覺? :睡出健康與學習力、夢出創意的新科學[讀書筆記] 金錢心理學: 打破你對金錢的迷思，學會聰明花費 (上)" }, { "title": "[Google sheet]如何在試算表裡匯入新聞、rss feed", "url": "/posts/google-sheet-google-news-rss-feed/", "categories": "Google Sheet", "tags": "google sheet, drop down list, finance", "date": "2021-07-18 12:00:00 +0800", "snippet": "此篇文章將分享我是如何在試算表裡查看新聞，看起來像是下面這樣:於左上角輸入公司名稱(此處是下拉選單)，即可跑出公司的相關新聞在這一篇[Google sheet]我如何製作股票損益表，自動抓取最新股價裡，我們已經建立了持有股票清單，我就想說如果同時可以同時看到每一間公司的相關新聞應該不錯，所以才會有了這篇．公式=IMPORTFEED(CONCATENATE(“https://news.google.com/atom/search?q=”, A1, “&amp;amp;hl=zh-TW&amp;amp;gl=TW&amp;amp;ceid=TW:zh-Hant&amp;amp;sort=rated”), “items”, false, 150)以上公式會使用A1儲存格的字去google news查詢，列出150項結果，以下將分別說明各個函式的用法.IMPORTFEEDIMPORTFEED爲要匯入新聞RSS Feed的函式，有四個參數，用法為: IMPORTFEED(網址, [查詢], [標題], [項數]) 網址 此處我們使用的網址為 https://news.google.com/atom/search?q=台積電&amp;amp;hl=zh-TW&amp;amp;gl=TW&amp;amp;ceid=TW:zh-Hant&amp;amp;sort=rated 改變q=後面的字，就是想要查詢的關鍵字 查詢 第二個參數，可以為下列這些: feed: 只傳回單一列資料 feed &amp;lt;type&amp;gt;: 可以指定傳回的特定屬性，可能是title、url、author、summary 舉例: IMPORTFEED(A1, “feed url”) items: 此為預設，傳回整個表格， items &amp;lt;type&amp;gt;: 一樣可以指定特定屬性， 舉例: IMPORTFEED(A1, “items title”, FALSE, 100) 標題 是否要納入標題欄，預設為FALSE 舉例: IMPORTFEED(A1, “items”, TRUE) 項數 當查詢(第二個參數)爲項目(items)時，代表要傳回的項目數 舉例: IMPORTFEED(A1, “items”, TRUE, 200) CONCATENATE就是把所有的參數串起來，例如=CONCATENATE(“123”, “456”)，就會相當於”123456”．也能使用儲存格當作參數，這裡的例子就是:=CONCATENATE(“https://news.google.com/atom/search?q=”, A1, “&amp;amp;hl=zh-TW&amp;amp;gl=TW&amp;amp;ceid=TW:zh-Hant&amp;amp;sort=rated”)，當A1為台積電時，就會相當於”https://news.google.com/atom/search?q=台積電&amp;amp;hl=zh-TW&amp;amp;gl=TW&amp;amp;ceid=TW:zh-Hant&amp;amp;sort=rated”Summary利用以上兩個公式，可能成功在試算表上看新聞囉～ 🎉，掰掰～👋" }, { "title": "[讀書筆記] 最高學以致用法: 讓學習發揮最大成果的輸出大全", "url": "/posts/book-notes-output/", "categories": "讀書筆記", "tags": "learning, writing, books", "date": "2021-07-14 17:10:00 +0800", "snippet": "不知道大家是否有過這樣的經驗: 讀了許多本書，事後卻說不出來到底讀了什麼;看了一場電影、經歷一趟旅程，卻分享不出想法、或是說出從中有哪些收穫．大家可能也有聽過，最好的學習方法就是去教人．教學就是一種輸出，本書作者認為自我成長的關鍵就是輸出，於本書收集了80個關於說、寫、行動三個面向的輸出，每一則皆為兩到三分鐘的時間就能閱讀完的份量，讓我們在自己的日常生活中尋找幾個可以小小進步的地方!原則此書的第一部分說明一些原則: 為什麼要輸出、什麼是輸出、輸入輸出的比例多少為好、以及除了輸出之外還需要些什麼?自我成長及改變生活的關鍵想讓自己成長得更快，重點不是多讀了多少書，關鍵是更多的輸出！透過分享、書寫、實踐，讓自己的記憶更加牢固，不管讀了多少書、上了多少課，如果沒有輸出實踐，不僅僅只是忘光光沒有記住而已，你的生活並不會有任何的改變 唯一可以改變現實的就是你的行為實踐兩週內運用三次情報及知識輸入到大腦裡，如果沒有經常運用很快就會忘記 透過反覆三次的輸出，讓情報成為長期記憶，儲存在大腦裡．輸入輸出比3:7有一個實驗是這樣子的，讓一群人去背社交名人錄的資訊，並依照不同的記憶時間，測驗時間，來看看最後誰的成績最好，結果發現最後成績最高的，是花了40%時間在學習的組別，年紀越大的則是30% 輸入和輸出的黃金比例，應該是3:7輸出之外還要有反饋單純不斷地輸入輸出，雖然也會有收穫，但如果沒有反饋就難以進步，有了反饋可以更知道下一次輸入的方向 補足弱點、發揮強項: 在輸出的同時，可以知道哪部分不夠清楚，再回頭去補強輸入，複習或是尋找相關資料，另外對於自己有興趣的部分，能夠做延伸學習～ 解決為什麼們: 在輸入輸出的過程中，一定會產生很多的疑問，不要放著這些為什麼不管，解決這些為什麼! 實踐分為說、寫、行動這三大類，作者整理了80個跟輸出有關的事，以下簡單地列舉一部分:說 分享前一天的事、體驗、感受 說正面而不是負面 非語言的表達的重要: 語調、表情、姿勢、肢體、動作 委婉地表達 關於提問、讚美、斥責、道歉、感謝 如何提問 關於簡報、打電話寫 寫下來～ 而且用手寫 關於做筆記、寫摘要 列出清單 彙整想法 製作企劃 引用行為 如何採取行動、並持之以恆 笑、哭 關於睡覺、運動 如何寫感想 社群、部落格心得感想讀完這本書之後，意識到原來生活當中，有如此多的面相都是輸出，而不是原本以為的發表演說、報告、寫文章而已．但就像這本書的主題輸出，如果沒有加以實踐，就不會有收穫，這也是我會開始寫這篇文章的原因，並且開始規定自己在輸出完一本書之前，不能再繼續讀下一本😂希望這讀書筆記系列可以持之以恆下去!也希望以上的內容，能稍微幫助到想認識這本書的人！掰掰～👋" }, { "title": "[Google sheet]我如何製作股票損益表，自動抓取最新股價", "url": "/posts/google-sheet-stock-income-statement/", "categories": "Google Sheet", "tags": "google sheet, finance", "date": "2021-07-09 16:30:00 +0800", "snippet": "此篇文章將分享我是如何製作我持有股票的未實現損益表，看起來的成果如下:主要功能 自動更新股價 根據最新股價，計算損益，並以顏色區分損或益 近一年的股價折線圖Step by Step製作表格首先填入表頭欄位，在這裡我們會有:股票代號、名稱、近一年股價、現價、漲跌、成交量、持有張數、市值、持有成本、損益、損益百分比每新增一檔股票，需要我們自己填入的有股票代號、名稱，持有張數、持有成本 股票代號: 爲後續GOOGLEFINANCE函式的參數，這裡以台北股市台積電為例爲TPE:2330 名稱: 就你自己開心如何稱這黨股票就好～ 持有張數: 就是你的持有張數… 持有成本: 每次買股票時，就將成本加上去吧取得最新股價資訊(現價、成交量)，計算市值 現價: 使用GOOGLEFINANCE函式來取得股價資訊！ 在D2儲存格中輸入公式: =GOOGLEFINANCE(A2, “price”)，之後下來套用至整個D欄 成交量: =GOOGLEFINANCE(A2, “volume”) 市值: 將持有張數及現價相乘即可～ =D2*G2 計算當日漲跌損益 漲跌: 有了現價，可以跟昨日收盤價做比較計算出今日漲跌: =D2 - GOOGLEFINANCE(A2, “closeyest”) 損益: 即為持有成本及市值相減: =H2-I2 損益百分比: 即為損益除以持有成本: =IF(ISBLANK(I2), 0, J2/I2)IF及ISBLANK的用途爲如果你尚未實有該檔股票，持有成本爲0或空白，卻又寫列入表中觀察，則損益百分比顯示為0，否則將出現錯誤． 股價折線圖公式為: =sparkline(GOOGLEFINANCE(A2, “price”,today()-365,today(),1)) GOOGLEFINACE:總共四個參數，第一為股票代號、再來是起始日期跟結束日期，此範例使用一年前today()-365到今天today()、最後爲資料的interval，1代表每天，也可以是7代表每週 sparkline:可以再一個儲存格裡畫圖的函式，詳細的用法可以看我先前寫的文章:[Google Sheet]Sparkline，在儲存格裡插入迷你圖表替漲跌及損益百分比上色最後！股市就是要紅紅綠綠才比較好看，將賺錢的部分標上紅色，虧錢的弄上綠色吧！首先點選漲跌那一欄(E)，接著點選工具欄格式 -&amp;gt; 條件格式設定將格式規則設為大於0，格式設定樣式改為字體紅色，綠色及損益率的部分也是一樣！如此一來就大功告成囉🎉" }, { "title": "[Google sheet]如何建立下拉選單，以及從既有資料中自動建立選項", "url": "/posts/google-sheet-create-a-drop-down-list-from-existed-data/", "categories": "Google Sheet", "tags": "google sheet, drop down list", "date": "2021-06-26 20:00:00 +0800", "snippet": "為什麼要用下拉式選單 新增資料更為快速，無需重複填寫 避免誤植，或統一資料的格式及規則 對既有資料鐘進行選擇及後續操作如何建立下拉式選單自行輸入清單選項 首先選擇一個或多個你想要建立選單的儲存格 點選 資料 -&amp;gt; 資料驗證 在條件選項中，選取項目清單 輸入你想要的選項，選項間以逗號隔開 就大功告成拉從既有資料來建立選項有時你想要建立一個選單，其中的選項是來自某一大筆資料中的某一個欄位，你不想一筆一筆手動Key，而且你也不想每次資料有變動時，就要重新去更新一次資料驗證，此時就可以這麼做，以以下的資料為例: 重複自行輸入清單選項中的第一及第二部 在條件選項中，選取範圍內的清單 輸入或選取一個範圍，以這裡的例子為例，我們建立一個國家的下拉選項，填入F2:F，代表country那一欄，不包含標頭country本身 大功告成~Summary建立一個下拉選單，選項可以自行輸入，也可以從既有資料的範圍中建立，如此一來當資料有變動時，下拉選單的選項就可以自動更新，而不需要自己再重新輸入新的選項!" }, { "title": "RESTful API Design — A practical guide", "url": "/posts/http-restful-api-design-practical-guide/", "categories": "Web Development", "tags": "api, http, restful api", "date": "2021-04-13 20:00:00 +0800", "snippet": "此篇文章將作為接下來一系列關於Restful API design的目錄．Part 1: 將介紹什麼是API，何時需要他，以及怎樣才會是一個好的API．Part 2: 在許多種API中，此系列只專注於HTTP RESTful API，為了更好地學習他，必須先了解HTTP Protocol，知道其中各個組成HTTP Message的每一個部分．Part 3: 介紹何為RESTful API，為什麼他會長這樣，以及其他許多當你在設計API時會遇到情況，例如: Documentation、Pagination、Rate Limiting、Monitoring．Part 4: 陸續想到一些相關的議題，再放上來！Outline Introduction 1.1 What is an API? 1.2 What is a good API? HTTP Basics 2.1 A HTTP Overview 2.2 HTTP Methods 2.3 HTTP Response status codes 2.4 HTTP URI 2.5 HTTP Headers 2.6 [Practices] A HTTP client — curl RESTful API and some Practical Guidelines 3.1 What is a RESTful API? 3.2 Identifying Resources 3.2 API first 3.3 An Introduction to OpenAPI 3.4 [Practices] How do I manage a large OpenAPI spec file? 3.5 Pagination 3.6 Rate Limiting 3.7 Monitoring Advanced Topics 4.1 Connection management 4.2 Resource Modeling: Fine-grained or Coarse-grained? 4.3 Versioning and Compatibility 4.4 How to Response to a Health Check? " }, { "title": "What are HTTP Methods？Which to use and How to use them correctly?", "url": "/posts/http-methods-which-to-use-and-how-to-use-them-correctly/", "categories": "Web Development", "tags": "restful api, api, http", "date": "2021-04-04 20:00:00 +0800", "snippet": "這篇文章主要討論幾個常見的HTTP methods，說明他們分別是否具有哪些特性(Safe、Idempotent)，以及他們應該要怎麼使用，比較會是符合大家的期待．當然寫server的人可以不照著慣例走，不過如此一來，使用這個API的user可能會很不高興，而這個user可以是公司的客戶，可能是公司內部的其他團隊，也可能是未來的自己！Outline HTTP Request message格式 常見的methods，以及其特性 分別介紹各個method的用法HTTP Request message一個general的HTTP request message如下：&amp;lt;method&amp;gt; &amp;lt;URL&amp;gt; &amp;lt;version&amp;gt;&amp;lt;header&amp;gt;......&amp;lt;header&amp;gt;&amp;lt;body&amp;gt; 第一個字就是method，接著為URL跟version，換行後為許多個header，每個header以換行隔開，最後再隔一行之後是body．對於HTTP message還不熟的，可以看我之前寫的文章：[Networking] HTTP 簡介，以及使用telnet、nc、curl等指令來探索URL代表著資源，而method是你想要對資源進行的操作，常見的method如下表：Don’t surprise your user並不是所有的server都會實作所有的method，而且每個method要做什麼事，也都是由server所決定的，但是一個好的API通常不會做怪怪的事，而是要符合使用者的期待，使其體驗良好，這裡先來解釋一下safe及Idempotent這兩個特性是什麼吧．Safe如果一個request是safe的，指的是他不會導致server去做一些額外的動作，沒有side effect，例如說改變state、刷你信用卡，這樣的request基本上就是read-only的．這樣的特性，使得API的user可以大膽放心地去呼叫，實驗你的API，而不必擔心會引發什麼無法挽回的後果，GET、HEAD、OPTIONS都是具有safe特性的method．Idempotent一個Idempotent的操作，指的是這樣的操作執行一次跟執行很多次的結果是一樣的．例如數學上的乘以1，乘以0，一個是數字乘以1或乘以0不管多少次，結果都是原本的數字或者是0．那有Idempotent的特性，可以帶來什麼好處呢？就是user可以放心的retry，當user不確定剛剛的operation、request有沒有成功時(可能送出後網路突然斷掉、server做完之後再回應之前掛掉、等等…)，就再做一次！而HTTP method中，除了POST，其他method都預期應該是Idempotent的，Update好幾次，Delete好幾次，應該都跟只做一次的結果一致．HTTP Methods看完了共同的特性之後，接著來看看給個method預期是怎麼使用，以及server如何回應各種情況．GET最常見的method之一，顧名思義就是用來向server索取一些資源． 有資源，server就回應200以及資源 沒有資源，404HEAD跟GET都一樣，但server並不回傳資源本身，而是只回應headers．&amp;lt;Response&amp;gt;HTTP/1.1 200 OKContent-Type: plain/htmlContent-Length: 614OPTIONS用來詢問server對特定的資源，有支援哪些操作． 將結果置於header Allow裡，如下： &amp;lt;Response&amp;gt;HTTP/1.1 200 OKAllow: GET, POST, PUT, OPTIONSContent-Length: 0 PUTReplace the entire resource，對應到CRUD裡的update，就是叫server將我request body裡的資料存起來，如果資源本來不存在就create，在的話就replace． 200 OK，成功 204 No Content，成功但畫面不需要更新，也就是沒有新的資料產生，client不必取的新的資料，例如說client在更新表單按下save時． 201 Created，如果是create的話，並且在header Location放上資源的URI &amp;lt;Response&amp;gt;HTTP/1.1 201 CreatedLocation: https://api.example.com/users/123 PATCHUpdate parts of the resource，跟PUT一樣是update，不過是partial update或者說是merge．比如說原本有個homuchen的user是長這樣：{ &quot;name&quot;: &quot;HoMuChen&quot;, &quot;age&quot;: 30}當你PATCH時，想要將age更新為31&amp;lt;Request&amp;gt;PATCH /users/homuchen HTTP/1.1Content-Type: application/jsonContent-Length: 11{&quot;age&quot;: 31}結果為{ &quot;name&quot;: &quot;HoMuChen&quot;, &quot;age&quot;: 31}如果是用PUT，則會整個replace掉，name就不見了{ &quot;age&quot;: 31}POST一般來說是指把資料傳給server去做處理，當使用其他的method，語意無法符合時，就會使用POST，常見的有用於Create resources、Search query、Asynchronous tasks． 200 OK 201 Created 202 Accepted，server已接受請求，但還需要時間去完成任務． Search Query: Ex. Elasticsearch Query DSLDELETE顧名思義，用來刪除資源． 200 OK． 207，bulk delete． 404 Not Found，要刪除的資源不存在． 410 Gone，資源已被刪除．SummaryHTTP做為網路世界中眾多通訊協定中的一個，只有當我們更加了解他，service provider才能提供更好用、另client user的學習曲線低，用起來很開心的服務．今天簡單地討論了各個HTTP Method的用法，每個method有他的語意，只有當server照著大家的預期去做時，才不會造成大家的困擾．除了Method之外，還有Response code、Header等其他HTTP的組成需要去了解，最後整個API符合RESTful的style是這一系列文章的目標．這是RESTful API一系列文章中的一篇，想了解更多關於RESTful API及HTTP的，可以看這篇目錄:RESTful API Design — A practical guide感謝您的閱讀~期待下次見！" }, { "title": "A Linux HTTP client tool — curl的介紹及用法", "url": "/posts/linux-http-client-tool-curl-usage/", "categories": "Networking", "tags": "http, linux, curl", "date": "2021-03-24 20:00:00 +0800", "snippet": "做為一個HTTP client，想要對server發出請求，有許多做法，可能是寫一個python script 或使用其他任何語言，也可以是使用postman這樣的工具，或者是直接在command line上或shell script中使用curl指令．當你想要快速地測試一下某個API，或是explore別人的HTTP service時，直接使用curl是還蠻方便的！甚至直接用shell script來寫爬蟲了！Outline HTTP Request message Curl 的許多參數及用法 如何知道自己curl有沒有寫對 其他常見搭配的用法及使用情境HTTP Request message作為一個HTTP client，要送出一個request，我們先必須知道送出去的message到底會有哪些東西組成．Request lineHTTP message的第一行，由method、URL、version所組成，例如：GET /index.html HTTP/1.1Header lines第二行開始，每一行是為一個header，field及value由冒號隔開，例如Host: www.google.comConnection: CloseAccept-Language: enbodyHeader結束空一行之後是為body，method是GET的就沒有body，例如你的表單POST的一些資料就會放在body，可能長這樣：name=HoMu&amp;amp;phone=0912345678&amp;amp;email=homu@email.com更多關於HTTP message的說明，可以看我之前寫過的文章：[Networking] HTTP 簡介，以及使用telnet、nc、curl等指令來探索Curl所以我們要如何使用curl指令來產生HTTP message呢？！基本URL是必須的，什麼參數都沒有，就產生一個GET messagecurl www.google.com-X設定你想要的method，例如你想要POST，如：curl -X POST api.host.com/v1/users-H加上headers，用冒號隔開field及value，如果想要多個header就多打幾次-H，如：curl -X POST \\ -H &#39;Content-Type: application/json&#39; \\ -H &#39;X-Whatever-Field: value&#39; \\ api.host.com/v1/users-d加上body，比如你想POST JSON string的data給你的API：curl -X POST -H &#39;Content-Type: application/json&#39; localhost:3000/api -d &#39;{&quot;name&quot;: &quot;HoMu&quot;, &quot;age&quot;: 30}&#39;如果你data很多，想在一個檔案裡頭，也可以使用指定檔案路徑的方式，可以為絕對路徑，也可以是相對的，路徑前必須加上@，例如：-d @./data.jsoncurl -X POST -H &#39;Content-Type: application/json&#39; localhost:3000/api -d @FILEPATH-i按下Enter後，你得到會是server傳回來的body，如果你想要看response的header的話，要加上-i-F上傳檔案利用nc指令看看自己到了傳了什麼你可能寫了curl指令，不太確定用法，想知道到底curl形成出來的message是不是自己想要的格式，這時可以使用nc指令，在本機端起一個tcp server，在curl這個server，就可以看到HTTP的message囉．nc監聽在port 3000nc -l 3000curl port 3000curl localhost:3000其他常見使用情況redirect當curl回來的資料是html時，直接在terminal上噴出一堆字也是很難看，這時長搭配redirect io，把回傳回來的html string寫到檔案裡，就可以用瀏覽器打開來了．curl www.google.com &amp;gt; gg.htmljq如果content-type是json的話，可以使用jq command幫你parse，不然一堆json string噴在螢幕上，也是眼花．curl api.host.com/users | jqSummary今天簡單看了一下HTTP message的格式，以及如何用curl來做出自己想要的HTTP Request，並且知道自己到底有沒有寫對．這是RESTful API一系列文章中的一篇，想了解更多關於RESTful API及HTTP的，可以看這篇目錄:RESTful API Design — A practical guide感謝您的閱讀~期待下次見！參考資料 https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages jq - https://stedolan.github.io/jq/" }, { "title": "HTTP 簡介，以及使用telnet、nc、curl等指令來探索", "url": "/posts/http-introduction-telnet-nc-curl/", "categories": "Networking", "tags": "http, linux, curl, nc, telnet", "date": "2021-03-24 20:00:00 +0800", "snippet": "在網路的世界裡，HTTP扮演著一個重要角色，當你打開Instagram看著無以計數的照片、打開Youtube看看影片、在google上搜尋著你想要知道的答案、瀏覽著別人的網站文章，這些都是HTTP負責把上述的這些照片、影片、文字、等檔案資源從別處的伺服器搬到你的裝置裡，可能是你的手機、平板或是電腦．HTTP在OSI模型中，是屬於應用層(Application layer)裡的一個通訊協定，透過傳輸層(Transport layer)的TCP來傳輸資料．關於application layer在整個分層架構中扮演什麼樣的角色，可以參考我之前寫的文章: [Networking]Application Layer Overview，什麼是Socket?Client server protocolHTTP是這樣的，想要發起通訊請求的一方作為client(例如你的瀏覽器)，而server則隨時等候，回應client的請求，client首先會建立一個TCP socket，至於TCP連線是怎麼建立，以及資料如何透過TCP connection在client及server之間傳送，則是另外一回事，並不是HTTP需要考慮的事．Client送出一個請求，例如我要看youtube! 而youtube的server收到這個請求，則回應給他youtube的介面，以及一些影片的清單．HTTP既然作為client及server之間的語言，他必須有個規範大家才聽得懂，不然有人講中文，有人說英文這樣是無法溝通的．以下就來看看HTTP所傳送的資料到底是長怎樣．HTTP messageHTTP message分成兩種，請求(request)及回應(response)，他基本上就是人類可以讀懂的文字．Request message以下一個範例，當你在網址上輸入www.google.com時，你的瀏覽送出去的HTTP message可能會是這樣:GET / HTTP/1.1Host: www.google.comConnection: CloseUser-agent: Mozilla/5.0Accept-language: en第一行為request line，由三個部分組成，method、URL、version，分別以空格隔開．常見的method有GET 、POST 、PUT 、DELETE 、HEAD等等，GET非常地常見，通常代表著你想要取得的某些資源，而你想取的資源則用URL表示，最後HTTP/1.1就是版本．點我看更多關於method的介紹．第二行開始為header lines，field跟value以冒號(:)隔開，上面例子中有Host、Connection、User-agent、Accept-language四個header，還有許許多多的header各自有各自的意義，Host代表server，Connection: Close是叫server回傳完資料後就把TCP connection close掉，關於persistent connections的部分，之後會再寫一篇文章來詳細探討．Request body如果client需要傳送額外的資料給server，就要把資料放在body的部分，是在header lines之後空一行，比如說我要通過一個API新增一個userPOST /users HTTP/1.1HOST: api.domain.comContent-Type: application/jsonConnection: Keep-alive{&quot;name&quot;: &quot;HoMuChen&quot;, &quot;age&quot;: 30, &quot;gender&quot;: &quot;male&quot;}Response message以下為一個範例:HTTP/1.1 200 OKServer: nginx/1.14.0 (Ubuntu)Date: Wed, 17 Mar 2021 14:34:29 GMTContent-Type: text/htmlContent-Length: 614Last-Modified: Wed, 17 Mar 2021 10:27:32 GMT&amp;lt;!doctype html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;........Status Line第一行為status line，由三個部分組成，version、status code、phrase，分別以空格隔開．Status code 跟 phrase拜表著回應的結果，常見的有： 200 OK：成功 301 Moved Permanently: 資源不在此URL，通常搭配著Location的response header，告訴我們要去哪裡取得資源． 400 Bad Request: Request有錯，我server看不懂拉． 404 Not Found: 資源不存在． 500 Internal Server Error: Server出事了…Header Lines第二行開始一樣是header lines，我覺得比較重要的是Content-Type，此header就是說明了放在最後body裡的資料是什麼格式，讓client可以去處理．常見的像是text/html、application/json、image/jpeg、application/pdf等等．Body結束header lines之後，空一行，後面就是response body的部分，放著的就是request想要的資料，上面例子中就是html document，也可能是一張圖片的binary data，或是一個Restful API的json資料．Get your hands dirtytext最後就來使用一些linux command line tool來驗證上面講的對不對吧！telnet www.google.com 80使用telnet指令，如此一來就跟google建立了一個TCP連線，接下來輸入並且按下EnterGET / HTTP/1.1Host: www.google.com就可以看到google把網頁吐回來拉～～nc、curl除了telnet之後，也可以用nc作為建立tcp連線的指令，這裡我們用nc來建立一個server，-l 監聽在本機的port 3000上nc -l 3000之後在另一個shell，利用curl作為HTTP client，發送HTTP到port 3000curl localhost:3000nc的terminal上就會出現這些資訊拉～～也就是curl傳送過來的資料，再來試試看上面開創一個新的user的API call吧curl -XPOST \\ -H &#39;Content-Type: application&#39; \\ -H &#39;Connection: Keep-alive&#39; \\ api.domain.com/users \\ -d &#39;{&quot;name&quot;: &quot;HoMuChen&quot;, &quot;age&quot;: 30, &quot;gender&quot;: &quot;male&quot;}&#39;nc server就會收到下面的資料拉！SummaryHTTP作為網路中最常用的client server 通訊協定，簡單地介紹了HTTP message的格式，他是human readable的text format，熟悉他到底傳來傳去到底在傳什麼，可以幫助我們開發網頁應用時更有底氣．也可以學習使用一些linux指令，快速的explore別人的API，或是看看自己送出去的request到底有沒有對．這是RESTful API一系列文章中的一篇，想了解更多關於RESTful API及HTTP的，可以看這篇目錄:RESTful API Design — A practical guide感謝您的閱讀~期待下次見！" }, { "title": "[System Design]Data model: Relational V.S. Document", "url": "/posts/system-design-data-model-relational-vs-document/", "categories": "Web Development", "tags": "data model, system design, database", "date": "2020-12-28 20:00:00 +0800", "snippet": "開發應用程式時，時常使用到資料庫，儲存資料並在之後需要時將其取出，如今有許多的資料庫產品可供選擇，提供各種不同的data model及function，在各種使用情境下有不同的表現，開發者根據你的應用程式的需求、資料之間的關係、access pattern、scalability、ACID transaction、fault-tolerance、會有各種不同的適合的選擇．接下來只單純討論資料庫提供給我們application programmer們的data model，看看是否在哪些情況比較適合用哪一種，主要是探討relational 及 document這兩種data model.One-to-many relationship讓我們先從一個簡單的例子Todo list開始，假設我們應用程式有使用者，每個使用者有多個Todo，就這麼簡單的一個one-to-many relationship．Relational DBMS如上圖， 一般使用SQL database的做法，會開兩個table，分別是users及todos，並且在todos table有個欄位user_id為foreign key指到user tableDocument database而在document database中，我們可以將整個資訊存成一個JSON document如上圖，當我們的UI需要呈現某使用者的todo的時候，資料庫只需要一個disk seek就可以拿到全部的資料，對比於relational database，必須在todos table裡找到相對應的rows，再將其與users的row合併．可以看到document database用來model one-to-many relationship的資料可說是天生的適合．Many-to-one and Many-to-many relationship現在假設我們要加入新的功能，使用者可以新增標籤，並把自己的Todo加上一個標籤．Relational database按照normalization的做法，就是再多一個tags table，user_id指向Users，而Todos再多一個foreign key指向Tags，如上圖沒什麼問題．而Document database則會向下圖這樣:資訊重複出現了好幾個地方，容易造成不一致，比如說我想把Coding改成Programming，除了在tags這個array裡面要修改之外，兩個todo裡的tag也要同時修改才行．Document database就不能做normalization嗎？當然是可以的！分別儲存三種類型的document: User、Tag、Todo，當某個user要取得他的資料時，就必須分別從三類document找出相對的document，在合併起來．那這跟relational database的join有什麼不一樣嗎？其實本質上是一樣的！只不過使用relational database時是database幫你做，而使用document database則是要在application code上面自己做，除了會有更多的network round trip time之外，relational database通常也會幫你優化．Schema flexibility另外他們倆之間常被討論到的不同，就是schema的有無，雖然說document database可以讓你隨意的放入任何的JSON document，但我們通常不會這樣做，一般來說都會把相同類型，有ㄧ樣資料格式的document放在一起，只不過資料庫本身並不會強迫每個document的schema要一模一樣．這樣的彈性，讓schema evolution也算方便，資料庫裡可以同時保有舊有的資料和新的資料 ，比如說todo想要新增一個欄位created_at，或是todo原本只能有一個tag，用一個string來表示，現在想要改成可以有多個tag，新新增的資料不在是一個string而是一個array．但如此一來application programmer在使用document database時，就不能保證拿到的資料的格式，會出現類似這樣的code:if (todo &amp;amp;&amp;amp; todo.created_at) { //...}if (todo &amp;amp;&amp;amp; Array.isArray(todo.tags)) { //...}時間久了，資料可能會越來越亂，一不注意就跑出個error:Cannot read property ‘some_field’ of undefined!該如何管理schema evolution，不讓你的應用程式crash，隨著新功能及新資料的加入能夠compatible，繼續穩定的運行就是另一門學問，有機會可以再來探討．What’s the situation preferring to schema-less approach?其實能有schema最好就有，他是你的資料的一個documentation，一個contract，讓programmer寫起程式來更有信心，不用擔心東擔心西，擔心會不會少了個欄位就讓我的process crash掉，那有什麼樣的情況會更適合使用document database嗎？ 資料來自外部，格式不是妳能控制的 有非常多種類的object，分別將每個object放到個別的table可能不太適合比如說event sourcing的架構，每種event type都有各自的資料格式，放在relation database的一個table，會有很多欄位是空的，schema定義起來也會非常麻煩．再來你的資料來源可能來自爬蟲、外部的API，格式可能改變，所以可以在拿到資料的時候就先存起來，之後讀的時候做處理，不然可能就會丟失部分的資料了．Summary如果你的資料之間的關係不複雜，基本上是one-to-many的，一個self-contained的JSON document能夠包含所有需要的資料，那麼document based的DBMS就相當適合，會有更好的performance，因為資料都在一起．Relational database更適合當你的資料之間的關係複雜，有許多many-to-one、many-to-many relationship時，幫你處理join的動作，雖說使用document database也是可以如此，但join的動作必須在application code上執行．另外document database也提供更彈性的schema，當你的應用需要面對許多不同且不確定、不是自己能控制的資料格式時，document database也許會有更好的support．Reference Designing Data-Intensive Applications Chapter 2 https://martinfowler.com/articles/schemaless/" }, { "title": "如何用create-react-app開發，整合一個或多個API backend server", "url": "/posts/create-react-app-integrate-multiple-api-backend-servers/", "categories": "Web Development", "tags": "react, create-react-app", "date": "2020-08-22 20:00:00 +0800", "snippet": "在開發single page application時，會需要透過api來取得及操作資料，本篇文章將示範如何在使用create-react-app開發時，整合一個甚至是多個backend api server！Create-react-app使用create-react-app時，簡單一個指令npm start 就可以開始開發，此時CRA會起一個webpack dev server來serve static files，通常我們會想要做類似這樣的動作: fetch(‘/todos’) 、fetch(‘/api/todos’) 來跟我們的API server通訊，此時該如何讓CRA的dev server將request proxy到我們想要的API server呢？透過package.json最簡單的方法就是在package.json中加一個proxy欄位，”proxy”: “http://localhost:5000” ，如此一來，所有的request便會被proxy到http://localhost:5000．想解決的問題這樣的做法很簡單但卻不太彈性，通常我們會希望外部的資源可以透過環境變數去控制，而不是寫死在檔案裡面，同一份codebase，透過設置不同的環境變數擁有不同的部署，可能是開發環境、測試環境、或staging、production環境 (https://12factor.net/codebase) ．另外將proxy寫在package.json中，只能將所有的ajax導到同一個server，假如您是service oriented architecture或microservices這種架構，可能會有許多的服務，例如data api、search api、authentication api、payment api等等．那該如何將不同的path，例如/api、/search、/auth，route到各自的服務呢？透過setupProxy.js首先需要安裝dependencynpm i -D http-proxy-middleware接著在src資料夾裡新增一個檔案setupProxy.js，範例如下:const { createProxyMiddleware } = require(&#39;http-proxy-middleware&#39;);const API_HOST = process.env[&#39;API_HOST&#39;];const SEARCH_HOST = process.env[&#39;SEARCH_HOST&#39;];const AUTH_HOST = process.env[&#39;AUTH_HOST&#39;];module.exports = function(app) { app.use( &#39;/api&#39;, createProxyMiddleware({ target: API_HOST, }) ); app.use( &#39;/search&#39;, createProxyMiddleware({ target: SEARCH_HOST, }) ); app.use( &#39;/auth&#39;, createProxyMiddleware({ target: AUTH_HOST, changeOrigin: false, }) );};如此一來，就能透過環境變數API_HOST、SEARCH_HOST、AUTH_HOST來指向你的服務，變且成功整合多個服務囉！" }, { "title": "[Networking]Application Layer Overview，什麼是Socket?", "url": "/posts/networking-application-layer-overview-what-is-socket/", "categories": "Networking", "tags": "linux, socket, tcp, udp", "date": "2020-05-05 20:00:00 +0800", "snippet": "Process communication上次講過了網路的分層架構之後，接下來要來關注application layer，這一層就是我們應用程式所在的地方，應用程式可能是網頁瀏覽器、電子信箱、Skype等等，每種不同的應用程式會有他們自己的通訊協定，規定應用程式之間該如何交換資料，以及資料的格式，常見的協定例如是HTTP、FTP、DNS等等．那application layer的process們之間要怎麼互相通訊呢？就是要利用transport layer所提供的服務．What is socket?Application layer的process必須使用transport layer所提供的服務來進行通訊，而這之間的介面就是socket，process只要把資料寫入socket，另一個process從socket讀出資料就好，就是這麼簡單～至於資料是如何在這之間傳遞的，底下的每一層 (transport、network、link、physical layer) 都幫你處理的好好的了，applications就只需要專心做自己的事就好！不過在通信之前，必須要知道對方在哪裡，資料才有辦法送到，一個socket就是一組ip:port pair，ip用來分別process所在的機器，而一台機器上會有許多的process，port number則用來分別是想要跟哪個程序溝通，有些服務基本上監聽在一些固定的port上，方便client來連，例如HTTP使用80、FTP用21、SSH使用22等等．另外當client要向server通訊時，作業系統會隨機指定一個port給他，如此一來server才會知道訊息要回傳到哪裡．Transport layer serviceApplication programer可以根據自己想打造的應用程式的需求，在兩種transport layer所提供的服務中選擇，一個是TCP，另一個是UDP，以下分別介紹．TCPTCP提供的是一個可靠的服務，確保資料一定會完整無缺的抵達另一端，使用TCP的application programmer不用擔心資料會到不了另一端，專心於application protocal就好．TCP有congestion control的機制，當網路變得壅塞的時候，會放慢sender的速度，這是為整個網路著想的設計，但對於application並沒有直接的幫助，可能還會使得速度變慢．UDPUDP的服務並不可靠，也就是並不保證資料一定會送達，對於一些應用來說或許是可以接受的，比如即時的通話或視訊，上一秒的聲音或畫面不見就不見了．是ok的．另外UDP也沒有flow control跟congestion control，sender想送多快就多快，所以如果有application覺得TCP做太多事了，開發起來綁手綁腳，想要看短的latency，就可以考慮使用TCP，例如google的QUIC就是基於UDP上，再重新自己實現了可靠的傳輸．Socket programming之後會寫一篇使用Node.js的net module來實際地使用一下TCP的服務，並在這之上打造自己的application protocol，待續…Application layer protocols接著也會陸續會介紹一些常用的application layer的protocol: HTTP、SMTP、DNS，待續…" }, { "title": "[Networking] 網路的架構，Layered Architecture", "url": "/posts/networking-layered-architecture/", "categories": "Networking", "tags": "networking, layered architecture", "date": "2020-04-04 20:00:00 +0800", "snippet": "網路是個如此巨大的工程，要如何架構，才能讓全世界的人通力合作，一起打造這豐富的世界呢？答案就是Layered Artichecture ．Layered Architecture網路的最終目的，就是讓兩個執行在不同機器的程式可以互相溝通、交換資料，例如你的瀏覽器chrome跟網頁伺服器溝通，你手機的Skype跟另一個人的Skype溝通，而這中間，資料經過了重重難關、無數的機器及路由器，這麼多的機器到底是如何一起合作的呢？答案就是分層的架構，Layered Architecture，生活中很多地方都可以看到類似的架構，我們以公司內部的信件為例好了，假設現在有一間公司有ABC三間分公司，在A公司的Alice想要寄封信給B公司的Bob，Alice首先寫了信的內容，將之放入信封內，並寫上收件人: B公司的bob，之後將信封交給A公司裡的一個叫做信件部門的部門，信件部門將信封寫上B公司的地址，再將信封交給附近的郵局，而郵局則使用卡車、飛機等運輸工具將信封運到B公司附近的郵局，此郵局再送到B公司，最後B公司的信件部門收到信，將他交給Bob．分層架構將一項任務分成了許多層，每一層只專心做自己的事，並且使用下一層所提供的服務．例如上圖中，人這一層，只專心將內容寫入信中，放進信封袋裡，然後交給下一層的信件部門就好，人這一層使用了信件部門這一層提供的服務，完全無需去擔心這封信最後是如何抵達另一個人那邊去，而信件部門層則使用郵局提供的服務，郵局服務提供了公司的工司的寄送，而信件部門就只專心將信件交給公司裡的某某人．Layers in the Internet網路世界的分層如下圖，根據OSI Model應該是有七層，但就目前常用，只介紹此五層，Application layer、Transmission layer、Network layer、Link layer、Physical layer．Application layer這裡就是我們的應用程式所在地方，根據你的程式所要達成的目的，各自執行著自己的協議．例如網頁瀏覽器跟伺服器，一個說給我看某某網頁首頁，伺服器就說，好！給你！這之間資料交換的格式及方法，就是由HTTP協議所規範，只要瀏覽器跟伺服器都遵守HTTP的規範就能互相溝通．電子信箱服務使用的則是SMTP，查詢網域ip位置的是DNS，傳輸檔案的FTP等等．而所有的application都必須依賴使用下層transmission layer的服務，transmission laye會負責applications之間的通訊，application只需要相信transmission layer會將信息傳遞給另一個application，專心做自己的事就好！Transmission layerTransmission layer protocol負責傳遞信息於application之間，一台機器上可能有多個application，而transmission layer protocol則是用port number來分辨到底目標是哪個process．目前網路世界中有兩種Transmission layer protocol，分別是TCP及UDP，TCP提供的服務保證資料一定會完整無誤地抵達目的地，並且還有flow control及congestion control．而UDP則沒做這麼多事，資料可能會丟失．Network layer每台連上網路的機器都會有個地址，有就是IP位址，Network layer中的唯一一個protocol就是IP protocol，負責將資料從一個IP送到另一個IP，也就是從一台host到另一台host！這之間會經過許多的router，每個執行IP protacol的router會決定要將封包傳遞給哪下一個router來抵達目的地，但並不保證封包一定會抵達．Link layer以上兩層當web dev以來，也從來沒碰過，哈！不熟，如果有興趣的人在自己去找資料囉～Physical layer這邊就是訊息從0101的bits轉換成真正物理世界裡存在的傳播媒介的地方了，可能是電磁波四處亂射，也可以是光走在光纖裡，或是電走在電線裡．Summary為了讓兩個在不同host上的process能夠通訊，首先你要指出你想要的通訊的process在什麼地方，透過ip:port這個pair，network layer會負責將信息送到擁有這個ip的機器，但卻不保證資料不會丟失，而network layer則透過port知道要將資料傳給哪個process，並且如果是TCP的話，會保證資料完好無缺地抵達另一個process那邊 (TCP可靠的傳輸建立在不可靠的IP上，酷吧！)，最後application根據自己的邏輯，來決定資料的格式，如何及何時發送和接收．" }, { "title": "[Networking]什麼是網路？網路的組成及網路服務供應商 ISP", "url": "/posts/what-is-networking-and-isp/", "categories": "Networking", "tags": "networking, ISP", "date": "2020-04-04 20:00:00 +0800", "snippet": "網路，可能是人類最大的工程成就之一，如今有數十億的人透過網路連接，在幾秒鐘之內就能夠互相通訊、完成某種任務，各種裝置互相連結，包括伺服器，個人桌上型電腦、平板、手機、未來還會有更多樣的things加入，例如車子、家電、各種感測器 ，等等．如此巨大的工程，大規模的全世界的共同合作，到底是如何做到的？工程架構的決定、協議的制定都值得去借鏡學習．網路的組成網路連接了世界上數十億的裝置，這些連上網路的裝置就稱為hosts, end-systems，而網路本身由communocation links及packets switches組成，links就是指電話線呀、同軸電纜、光纖、電磁波頻譜這些實際傳送資料的媒介，而資料從一個host到另一個host是被拆分成許多一個一個的packet，藉由link傳送，到達packets switches，每個switch則負責把packet從進來的link選擇一個link傳出去，最後到達目的地．那到底是誰提供這些links及switches給我們的裝置去連接上呢？就是網際網路服務供應商，Internet Service Provider，ISP．Internet Service Provider(ISP)在台灣，當我們想要使用網路時，就要去找中華電信、遠傳、台灣大哥大等等的電信商，他們就是ISP，負責建設基礎設施，設定連結，我們透過行動網路、光纖、DSL連上，網路供應商的設備就會負責傳遞資料來往於我們與目的地之間．比如A跟B都去了中華電信申請了網路服務，連接上後A及B之間就能互相通訊了，那現在C使用了遠傳的服務，AB及C該要怎麼通訊呢?如果中華電信跟遠傳之間互相連接起來就可以了．那全球有那麼多的用戶，各自使用各自的服務供應商，如果全部都必須要能夠互相通訊，就必須要全部的網路服務供應商都互相連接才行，但這要有點太不實際了，連結的數量太過龐大，成本非常高．現在假設有個全球範圍的服務供應商，各地區的供應商只要接上去就可以了，下層的服務供應商成了上層的客戶，依據流量付費，有錢賺的生意當然就有許多人進來做，許多競爭的供應商加入，彼此也可以互相連結，客戶也可以跟多個供應商合作，如此當有任一供應商服務中斷，也不會影響終端用戶．於是網路就成了階層式的架構，上下層的客戶關係，同層之間也會互相連接，各個供應商自己負責建設自己的基礎設施及設定路由，封包的傳送可能會有經濟的考量(盡量不走上層供應商，因為要錢，只在同層之間交換)、或者是政治考量(不想封包經過某某國家的設備，或是所以封包都要經過某地，以利監控、阻擋某些來源)．" }, { "title": "[Google Sheet]Sparkline，在儲存格裡插入迷你圖表", "url": "/posts/google-sheet-sparkline/", "categories": "Google Sheet", "tags": "google sheet, sparkline", "date": "2020-01-23 20:00:00 +0800", "snippet": "Sparkline用起來長怎樣我在[Google Sheet]我如何製作進度表這篇裡以及[Google sheet]我如何製作股票損益表，自動抓取最新股價大家可以看到一些儲存格裡都有迷你圖表，像是柱狀圖、線圖，這就是sparkline這個函式的功用，讓我們不需要額外插入一些圖表，就能直接在格子中畫圖．Sparkline用法sparkline(range, [options])range就是你的資料，是一個範圍，比如A1:A10、C3:L3options則是一些其他設置，可有可無，例如圖表的類型是line、bar，圖表的顏色，線條粗細等等．寫法為在一個大括號內{}，一連串的屬性及相對應的值，以分號(;)分開，例如：{“charttype”,”bar”; “color”,”blue”; “max”,1}圖表類型圖表的類型可以在options裡透過charttype屬性設置有幾種選擇line, bar, column, winloss (預設為line)charttype, line: 折線圖 color: 線的顏色 linewidth: 線的粗細charttype, bar: 堆疊長條圖 max: 設定橫軸的上限值 color1: 兩個堆疊交錯的長條圖，第一種的顏色 color2: 兩個堆疊交錯的長條圖，第二種的顏色charttype, column: 直條圖 color: 直條圖的顏色 lowcolor: 最低值的顏色 highcolor: 最高值的顏色 firstcolor: 第一欄的顏色 lastcolor: 最後一欄的顏色 ymin: 欄高的下限值 ymax: 欄高的上限值範例黑色折線圖sparkline(E1:E10)藍色且較粗的折線圖sparkline(E1:E10, {“color”,”blue”; “linewidth”, 2})堆疊長條圖sparkline(H1:H10, {“charttype”,”bar”; “max”, 50})Bar為堆疊長條圖，交替兩個顏色一個疊著一個，max50為上限值，也就是當值疊加到50時會填滿那一欄．長條圖sparkline(H1, {“charttype”,”bar”; “max”, 5})這裏我們資料只有一個值，也就是H1的1，當值等於max的5時就會填滿整格，常可以用來代表進度，例如值為百分比而max為1直條圖sparkline(H1:H10, {“charttype”,”column”})" }, { "title": "什麼是message queue? 優點及使用場景", "url": "/posts/message-queue-advantages-use-cases/", "categories": "Web Development", "tags": "message queue", "date": "2019-12-13 20:00:00 +0800", "snippet": "在大型網頁應用程式系統中，當我們的服務越來越多，服務之間就需要溝通，透過http restful api，想必大家都一定遇過，或許或多或少也聽過使用message queue，那到底它是什麼？為什麼要用它？以及跟restful api有何不同的使用場景呢？什麼是message queue?顧名思義，就是有個queue，訊息先入先出( FIFO )，基本上就是提供一個讓不同process間通訊的方式( asynchronous messaging )，會有產生訊息的producer，及消耗處理訊息的consumer．為何使用？為什麼要使用message queue呢？ 他能帶給我們哪些好處？Fault tolerance一但訊息被成功送進queue裡，在他被成功消耗掉之前，都會保存著，有時可能因為莫名原因，consumer都掛了，在consumer恢復之前，需要做的任務還留著，能夠等到恢復之後再繼續處理．Decoupling訊息的發送方和接受方都不需要知道彼此，consumer和produce可以隨便你用不同語言實作，只要message的格式事先有溝通好，知道就好．Scaling系統可能有時會突然面臨大的流量，此時queue就提供了一個buffer的功能，能夠緩衝尖峰流量，在資源固定的情況下，能夠處理更多的任務，以時間換取資源！但有時訊息可能真的太多，產生的速度快於消耗的速度，或是你無法接受太長的latency，此時consumer process就可以隨時增加多個，不會有衝突的風險．Compare to RESTful API同樣都是透過network，processes之間的通訊，他們之間最大的不同就是一個是asynchronous message passing，而HTTP request是synchronous(同步)的，也就是client發出了request，會等待在那邊，期待著response回來，所以latency就是一個重要的指標，也主要影響use cases的因素(見下段)．Use CasesLatency不重要的時候Sending emails這類工作，使用者可以接受信晚個幾秒，幾十秒甚至幾分鐘到時．或是比如Build一個你的產品的search index，資料不是由使用者寫入，他也不會知道何時資料應該要出現，就不會怪你的系統怎麼這麼慢拉．Computing heavy jobs比如說image resizing或是video encoding這類CPU intensive的工作，一來是使用者上傳完圖片影片，可能不需要等到這類都做完了你才跟他說ok，二來是你也不會想讓這類工作block住或拖垮你的web server的效能．無法控制的工作當你的工作需要協調許多資源才能完成時，往往可能一個資源overloaded，就會造成整個工作變得很慢，尤其是當資源又是外部的你無法控制時．Tools主要的Message broker分成兩類，memory based及log based，各類比較知名的分別像是RabbitMQ及Kafka，對於他們的用法及使用場及不同有興趣的，可以看我的另一篇文章:Difference bwtween rabbitmq and kafkaTutorial之前有寫過的使用Redis來當作message broker的示範:如果你連Redis都不想架！可以使用GCP的服務Pub/Sub，上GCP的網站點一點，開箱就用！" }, { "title": "快速擁有一個Asynchronous Task Queue，使用Redis and Kue.js", "url": "/posts/asynchronous-task-queue-using-redis-and-kue-js/", "categories": "Web Development", "tags": "message queue, node.js, redis", "date": "2019-10-30 20:00:00 +0800", "snippet": "這是篇教你如何在node.js環境下，快速擁有一個Task queue的tutorial，如果想了解什麼是message queue，以及為什麼跟什麼時候要使用它，可以參考我的另外一篇文章!Outline 部署Redis，使用Docker，在本地起一台Redis 介紹Kue.js部署Redis先準備一個shell script run_redis.sh ，記錄下docker指令，以便之後繼續使用，內容指令如下：#!/bin/shdocker run \\ -d \\ -p 6379:6379 \\ -v $PWD/redis_data:/data \\ --name my-redis \\ redis解釋一下這個docker指令各個參數的意義: -d 在背景執行 -p 6379:6379將容器內的port:6379映射到本機的port:6379 -v 將容器內的檔案掛載到本機，此處將容器內存放redis 資料的資料夾 /data 掛載到$PWD/reids_data，也就是當前目錄的redis_data資料夾 redis為image的名稱，可以用例如redis:latest, redis:5.0，後面加上版本號，沒加就是latest，可用的版本及latest是哪一版可以從此連結查詢https://hub.docker.com/_/redis/執行完之後執行 docker ps 就可以看到container的資訊如下介紹Kue.js安裝$ npm install kueConnectionvar kue = require(&#39;kue&#39;)var queue = kue.createQueue();預設會連接到127.0.01:6379的redis，如果想要改變，可以var queue = kue.createQueue({ redis: { port: 1234, host: &#39;10.0.50.20&#39;, auth: &#39;password&#39;, db: 3, // if provided select a non-default redis db options: { // see https://github.com/mranney/node_redis#rediscreateclient } }});Produce message連接到message broker後，就可以開始送message過去拉～queue.create(&#39;email&#39;, { title: &#39;welcome email for tj&#39;, to: &#39;tj@learnboost.com&#39;, template: &#39;welcome-email&#39;,}).save( function(err){ if( !err ) console.log( job.id );});這裡我們發送了一個message到名為email的queue裡，內容就是個JSON object.Consume message接著我們就可以在別的地方，接收發出去的訊息及處理拉queue.process(&#39;email&#39;, function(job, done){ doSomethingWithData(job.data) done();//acknowledge this message});queue.process接收兩個參數，第一個是queue的名字，這裡是以’email’為例，第二個參數是一個callback function，他有兩個參數，分別是job跟done，job.data就是我們剛剛發送出去的message，而done是一個function，當你確定這個message已經處理完的時候可以執行done()Concurrency controll上面例子中，一次只會接收一個message直到你ack這個message，如果你的工作是IO密集的話，你可能會想一次同時處理多個message，此時可以在process function中，加入第二參數:queue.process(&#39;email&#39;, 10, function(job, done){ doSomethingWithData(job.data) done();//acknowledge this message});這樣一來，這個worker process同時就可以接收處理10個message!以上是簡單地介紹如何連接到message broker，以及產生和消耗信息，完整的說明文件及更多功能用法，可以到github上看看:Automattic/kue" }, { "title": "[Google Sheet]我如何製作進度表", "url": "/posts/google-sheet-track-progress/", "categories": "Google Sheet", "tags": "google sheet, sparkline", "date": "2019-08-14 20:00:00 +0800", "snippet": "追蹤每項任務到目前為止的進度，或每段時間(每天、每個禮拜、或每個月)的努力情況首先先把任務跟時間輸入進去，如下圖: 時間只要輸入兩格就可以了，點住右下角的小藍點往右拉，就會補上一樣間距的時間，也就是說那兩格如果是差一天，之後每一格都會差一天，一個禮拜、一個月亦然． 代表每項任務需要完成的單位，簡單用數字量化表示，比如一堂課有10週的課程，就輸入10． 每個時段，完成某個任務多少單位，就填在這個地方． C4那格裡的公式是=sum(D4:Z4)/B4，就是簡單地將同個任務右邊的每個時段完成的單位(D4:Z4)加起來，再除以Total Unit(B4)，做完後往下拉，每個任務的progress就都有了． C4=SPARKLINE(SUM(D4:Z4)/B4,{“charttype”,”bar”;”max”,1}) ，這裡使用了SPARKLINE這個函式，將(4)所計算出來的值丟進去第一個參數，第二個參數{“charttype”,”bar”;”max”,1}代表著我們要的是柱狀圖，且最大值為1，因為進度是一個0–1的數字． 增加一列Total，將每個任務的Total unit，progress及每周的進度都加總起來，以此為例B11 = SUM(B4:B10)，然後再往右拉，應用到每一格上． 製作每時間區間進度條，只是將上述第6步驟的值視覺化: 先將日期上面的格子全部合併成一格，將D1:N1選起來，從格式 → 合併儲存格 → 全部合併 這一格 =SPARKLINE(D11:N11, {“charttype”,”column”})，ㄧ樣使用SPARKLINE函式，如果想要一條線就=SPARKLINE(D11:N11)就好，看起來就像這樣 大功告成～～🎉🎉🎉Referece [Google Sheet]Sparkline，在儲存格裡插入迷你圖表" }, { "title": "InstMap TW — 從地圖上找尋附近的台灣Instagram熱門景點", "url": "/posts/instmap-tw-popular-location-on-map/", "categories": "Web Development", "tags": "instagram, react, node.js, express, gcp", "date": "2019-03-25 20:00:00 +0800", "snippet": "到了一個地方，想知道附近有什麼好玩的景點嗎？想看看IG，Instagram上大家都去哪裡嗎？可以使用我最近做的一個玩具服務InstMap TW，找尋台灣最多人標記的地標，或是附近最近的相對熱門的地標．點選地圖旁的小人圖案，可以使用您現在的位置做搜尋，不想開定位的話，也可以手動拉動地圖改變中心點．每個地點點進去可以看到該地點的貼文，可切換成瀏覽圖片或是日期、文字、按讚數、留言數等相關資訊．使用到的技術、工具、服務大概是 Front-end react redux create-react-app Back-end web server Nginx ExpressJS Cloud service AWS DynamoDB Cloud Firestore Cloud functions Cloud Pub/Sub Cloud Schedule Compute Engine " }, { "title": "利用Docker建立PostgreSQL開發環境", "url": "/posts/docker-postgres-dev-environment/", "categories": "Web Development", "tags": "docker, postgres", "date": "2018-07-25 12:19:15 +0800", "snippet": "首先先將需要的configuration variable放到環境變數裏，在這裡就是我們的PostgreSQL database server要起在哪一個port，user，password，db等等，準備好你的 dev.env檔案如下，然後執行 . ./dev.envexport PG_PORT=5432export PG_USER=adminexport PG_PWD=secretpwd再來是一個shell script run_postgres.sh ，記錄下docker指令，以便之後繼續使用#!/bin/shdocker run \\ -d \\ -p $PG_PORT:5432 \\ -e POSTGRES_USER=&quot;$PG_USER&quot; \\ -e POSTGRES_PASSWORD=&quot;$PG_PASSWORD&quot; \\ -v &quot;$PWD/pgdata&quot;:/var/lib/postgresql/data \\ postgres解釋一下這個docker指令各個參數的意義: -d 在背景執行 -p $PG_PORT:5432 將容器內的5432port映射到本機的$PG_PORT -e 注入環境變數到容器裏，有哪些環境變數可用，可以參考官方連結https://hub.docker.com/_/postgres/ -v 將容器內的檔案掛載到本機，此處將容器內存放postgres 資料的資料夾 /var/lib/postgresql/data 掛載到$PWD/pgdata，也就是當前目錄的pgdata資料夾 postgres為image的名稱，可以用例如postgres:latest, postgres:9.6，後面加上版本號，沒加就是latest，可用的版本及latest是哪一版可以從此連結查詢https://hub.docker.com/_/postgres/執行完之後執行 docker ps 就可以看到container的資訊如下接下來要進去容器裡面create table，下下sql指令的話，就是執行docker exec -it {container id} psql -U $PG_USERPG_USER是我們的環境變數，預設的DB(此處為admin)的名字就跟PG_USER一樣，進去容器之後看到如下，就可以開始使用拉～" }, { "title": "使用Node.js + Express整合Line Notify通知服務", "url": "/posts/express-line-notify-service/", "categories": "Web Development", "tags": "express, node.js, line notify, middleware", "date": "2017-12-28 20:00:00 +0800", "snippet": "快速簡單地使用一個express的middleware完成line notify的oauth2流程，取得access_token來做後續的消息推送使用line notify可以簡單地讓網站開發者推送訊息到使用者的line裡，雖不像line bot可以跟使用者做更多的互動，但如果只是要單方面的的發送訊息，使用line notify就足矣，而且還不像line bot的push api要收費，這個不用錢～登入流程Line notify的流程大致來說是這樣的: GET https://notify-bot.line.me/oauth/authorize 帶著你的client id及redirect_uri，GET上面的url，使用者就會被導到line的登入頁面 登入成功之後，line那邊會倒回上述的redirect_uri並且query string帶著code2.POST https://notify-bot.line.me/oauth/token 將第一步得到的code，post到上述url，就可以拿到一個token POST https://notify-bot.line.me/api/notify 帶著上面步驟所取得的token及訊息，post上面的url，使用者就可以收到消息拉～ 套件使用接下來要實作以上流程覺得好麻煩喔～小的已將上述前兩個步驟寫成一個express的middleware供大家使用，說明如下： npm install express-line-notify 傳入config物件，需要clientId及clientSecret 選個endpoint來走以上oauth2流程，記得endpoint要加在callbackurl裡 const express = require(&#39;express&#39;);const lineNotify = require(&#39;express-line-notify&#39;);const config = { clientId: &#39;your-client-id&#39;, clientSecret: &#39;your-client-secret&#39;,}const app = express();app.use( &#39;/endpoint_u_want_to_use&#39;, lineNotify(config), otherMiddleware);app.listen(3000); 4.如上實作之後，便可以在otherMiddleware裡的req[‘line-notify-access-token’]拿到token拉～就可開發者要怎麼使用了 最後附上git hub repository，有較為詳盡的使用說明．HoMuChen/express-line-notify" } ]
